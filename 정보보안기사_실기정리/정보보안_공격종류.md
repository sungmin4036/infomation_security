- [HEIST(HTTP Encrypted Information can be Stolen through)](#o-heisthttp-encrypted-information-can-be-stolen-through--공격-2016년-8월-black-hat-발표)          
- [DROWN(Decrypting RSA with Obsolete and Weakened eNcryption)](#o-drowndecrypting-rsa-with-obsolete-and-weakened-encryption-공격-2016년-3월-cve-2016-0800)          
- [FREAK(Factoring attack on RSA-EXPORT Keys)](#o-freak-factoring-attack-on-rsa-export-keys-공격2015년-1월-cve-2015-0204)          
- [POODLE(Padding Oracle On Downgraded Legacy Encryption)](#o-poodlepadding-oracle-on-downgraded-legacy-encryption-공격2014년-10월-cve-2014-3566)          
- [Heartbleed 취약점](#heartbleed-취약점-2014년-4월-cve-2014-0160)          
- [Insecure Deserialization(안전하지 않은 역직렬화)](#ㅁ-insecure-deserialization안전하지-않은-역직렬화)          
- [CSRF 공격(Cross Site Request Forgery)](#ㅁ-csrf-공격cross-site-request-forgery)          
- [SSRF(Server-side Request Forgery) ](#ㅁ-ssrfserver-side-request-forgery)          
- [Shell shock](#ㅁ-shell-shock)          
- [반사 XSS Attack](#반사-xss-attack)          
- [DOM 기반 XSS Attack](#dom-기반-xss-attack)          
- [SQL Injection](#ㅁ-sql-injection)          
- [XXE(XML eXternal Entity, XML 외부 엔티티)](#ㅁ---xxexml-external-entity-xml-외부-엔티티)          
- [XML 이란?   ](#ㅁ-xml-이란)          
- [파일 인클루전(file inclusion) 공격](#ㅁ-파일-인클루전file-inclusion-공격)          
- [DNS 증폭 공격(Amplification Attack)](#dns-증폭-공격amplification-attack)          
- [NTP 증폭 DRDoS 공격(Amplification Attack )](#ntp-증폭-drdos-공격amplification-attack)          
- [SSDP Amplification DDoS](#ssdp-amplification-ddos)          
- [VSE Query Flooding](#vse-query-flooding)          
- [GRE Flooding](#gre-flooding)          
- [Tsunami Syn Flooding](#tsunami-syn-flooding)          
- [GET Flooding](#get-flooding)          
- [SYN Flooding](#syn-flooding)          
- [UDP Flooding](#udp-flooding)          
- [ICMP Flooding](#icmp-flooding)          
- [CLDAP DDoS Attack](#cldap-ddos-attack)          
- [TCP Connection Flooding](#tcp-connection-flooding)          
- [Http GET Flooding](#http-get-flooding)          
- [Slow HTTP POST DoS  ](#slow-http-post-dos)          
- [Slow HTTP Header DoS     ](#slow-http-header-dos)          
- [DNS Spoofing Attack](#dns-spoofing-attack)          
- [DNS 캐시 포이즈닝 (Cache Poisoning)](#dns-캐시-포이즈닝-cache-poisoning)          
- [DNS를 활용한 증폭 DrDoS](#dns를-활용한-증폭-drdos)          
- [회선 태핑(Tapping) 공격](#회선-태핑tapping-공격)          
- [템페스트(Tempest) 공격](#템페스트tempest-공격)          
- [VLAN 홉핑 공격](#vlan-홉핑-공격)          
- [DHCP 스푸핑 공격](#dhcp-스푸핑-공격)          
- [본크·보인크(Bonk·Boink) 공격](#본크보인크bonkboink-공격)          
- [Tiny Fragment Attack](#tiny-fragment-attack)          
- [Fragment Ovelap Attack](#fragment-ovelap-attack)          
- [세션 하이재킹](#세션-하이재킹)          
- [Smishing](#smishing)          
- [Spear Phishing](#spear-phishing)          
- [Qshing](#qshing)          
- [파일 업로드 공격 ](#ㅁ-파일-업로드-공격)          
- [Ping of death ](#ㅁ-ping-of-death)          
- [Trinoo](#ㅁ-trinoo)          
- [John The Ripper ](#ㅁ-john-the-ripper)          
- [스턱스 넷](#스턱스-넷)          
- [DHCP Starvation](#dhcp-starvation)          
- [ARP Spoofing](#ㅁ-arp-spoofing)          
- [ARP Redirect](#ㅁ-arp-redirect)          
- [ICMP Redirect](#ㅁ-icmp-redirect)          
- [Dos vs DDoS vs DRDOS]





---

[DoS]
![image](https://user-images.githubusercontent.com/62640332/138556466-a7ab272f-1125-4951-a421-ff8277e7cb37.png)

[DDOS] 
![image](https://user-images.githubusercontent.com/62640332/138556495-bc84ebbb-4277-417f-88fc-a65ae14337f2.png)

[DrDoS] 
![image](https://user-images.githubusercontent.com/62640332/138556534-1a72e70f-49cb-45d8-8031-fbe2f096dc83.png)

***

### ㅁ MIME 타입   

***
: MIME 타입이란 클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘   
웹에서 파일의 확장자는  의미X 각 문서와 함께 올바른 MIME 타입을 전송하도록, 
서버가 정확히 설정하는 것이 중요
- Type: text, image, audio, video, application

> - Image Type: image/ gif, jpeg, png, svg+xml   
> - Aduio Type: audtio/ wave, wav, x-wav, x-pn-wav, webm, ogg   
> - Video Type: video/ webm, ogg   
> - Application Type: application/ ogg   

<br>

- 서버측에 있는 프로그램을 서버 사이드 프로그램
- 서버 사이드 스크립트는 프로그램 중에서도 스크립트 형태의 프로그램



<br>
<br>

***
 #### ㅁ SSL/TLS
 - SSL(Secure Sockets Layer)
 - TLS(Transport Layer Escurity)
: 네트워크 통신 환경에서 주고받는 데이터를 암호화 해주는 규약(다양한 애플리케이션에서 암호화된 통신을 위해 사용)

ㅁ SSL/TLS 주요 보안 이슈
### o HEIST(HTTP Encrypted Information can be Stolen through  공격 (2016년 8월, Black Hat 발표)

: 브라우저에 대한 사이드-채널 공격(side-channel attack)(8)을 통해 SSL/TLS로 암호화된 데이터의 정확한 크기를 알아내는 공격   
이미 알려진 이전 공격과 HEIST의 차이점은 중간자 공격(man-in-the-middle attack, MITM)(9) 없이 사용자의 브라우저만 있으면 웹사이트의 광고 등에 몰래 숨겨 놓은 악성 JavaScript를 이용하여 공격 가능    
HEIST를 이용하여 암호화된 데이터 크기를 정확히 알아내기만 하면 압축-기반 공격(compressionbased attack)(10)이나 크기-노출 공격(size-exposing attack) 등에 취약해져 사용자계정, 패스워드, 의료데이터 등 민감한 정보가 탈취될 가능성이 높아짐      
JavaScript의 Fetch API(데이터 전송 시작)와 타이밍 API(데이터 전송 종료)를 사용하면 첫 번째 TCP window(11) 안에 암호화된 데이터가 전송 완료되었는지 아니면 두 번째 TCP window 안에 전송 완료 되었는지를 알아낼 수 있음           

### o DROWN(Decrypting RSA with Obsolete and Weakened eNcryption) 공격 (2016년 3월, CVE-2016-0800)
: RSA 키교환 단계에서 암호화된 세션키(서버와 클라이언트 간 데이터를 암호화하는 대칭키)를 해독하는 공격   
 SSL 2.0 프로토콜에서 사용된 RSA 개인키(private key)와 동일한 개인키를 사용하는 RSA 키교환 기반의 TLS 연결은 DROWN 공격에 의해 암호화된 통신이 해독될 수 있음
 DROWN 공격은 SSL 2.0에서 사용한 RSA 개인키를 유출하는 것이 아니라 Bleichenbacher RSA패딩 오라클 공격을 통해 암호화된 세션키를 해독함
 SSL 2.0과 동일한 개인키를 사용하는 RSA 키교환 기반의 TLS 연결은 해독된 세션키를 이용하여 복호화 할 수 있기 때문에 클라이언트와 서버 간 비밀 통신을 엿볼 수 있음

![image](https://user-images.githubusercontent.com/62640332/136651311-3750ddce-806b-48e2-bb0f-be38a56d9c40.png)

### o FREAK (Factoring attack on RSA-EXPORT Keys) 공격(2015년 1월, CVE-2015-0204)
: 공격자는 중간자 공격(man-in-the-middle attack, MITM)을 통해 SSL 연결시 보안이 취약한 “수출 등급” RSA 알고리즘을 사용하도록 유도한 후 brute-force 공격(14)으로 RSA키를 알아내는 공격
과거 미국에서는 자국 소프트웨어 수출시 암호화 수준을 낮추도록 규제하였는데 이를 “수출 등급(export-grade)” 암호화 알고리즘이라 함
RSA_EXPORT는 512비트의 암호화키를 사용하는 수출 등급의 RSA 암호화 알고리즘으로서 현재 주로 사용되는 2,048비트 이상의 암호화키에 비해 brute-force 공격에 취약
![image](https://user-images.githubusercontent.com/62640332/136651398-33bffaed-0a8d-4c24-932e-fbebe2f548a7.png)
- OpenSSL 0.9.8zd 이전 버전과 OpenSSL 1.0.0 ~ 1.0.0p 버전, OpenSSL 1.0.1 ~ 1.0.1k 버전 등이 취약하기 때문에 최신 버전으로 패치해야 함
- 패치가 적용되기 전까지는 “RSA_EXPORT Cipher Suites” 비활성화 필요


### o POODLE(Padding Oracle On Downgraded Legacy Encryption) 공격(2014년 10월, CVE-2014-3566)
: SSL 3.0은 Netscape사가 웹에서 암호화된 통신을 위해 1996년 발표한 스펙으로써 패딩 오라클 공격(Padding Oracle Attack)에 취약하여 2015년 RFC 7568에 의해 공식적으로 사용 제한(DEPRECATED) 됨
 POODLE 공격은 SSL 3.0의 CBC(Cipher Block Chaining) 암호 모드의 취약점을 통해 패딩 오라클 공격을 수행하여 주고받는 암호문을 해독할 수 있음
 
  - 공격자는 SSL 3.0의 패딩 오라클 취약점을 이용하기 위해 중간자 공격을 통해 TLS 연결 시도를 모두 무시(drop)하고 SSL 3.0 연결을 유도함
 
 SSL 3.0으로 연결되면 자바스크립트를 이용하여 브라우저가 특정 사이트의 인증정보(쿠키, 토큰 등)를 탈취할 수 있으며 패딩 오라클 공격으로 암호문을 해독할 수 있음

> ![image](https://user-images.githubusercontent.com/62640332/136651577-d36e5c48-ed47-4600-bb91-603e05148a56.png)

> - POODLE 공격을 대처하는 최선책은 더 이상 SSL 프로토콜을 지원하지 않는 것
> - 서버는 웹서버 설정을 통해 SSL 3.0 프로토콜 미지원 조치
> - 클라이언트는 브라우저 설정을 통해 SSL 3.0 연결 제한 조치

### Heartbleed 취약점 (2014년 4월, CVE-2014-0160)
: TLS/DTLS(15)에서 keep-alive 기능을 제공하는 Heartbeat Extension 스펙(16)이 OpenSSL 라이브러리에서 잘못 구현되어 공격자는 웹서버의 시스템 메모리 내용을 탈취할 수 있음
이러한 취약점에 Heartbleed(심장출혈)라는 별명이 붙게 된 이유는 공격자가 스펙과 다른 Heartbeat을 서버에 지속적으로 보내면 이러한 취약점을 갖고 있는 서버의 응답에 민감한 정보가 조금씩 흘러나오기 때문임
Heartbeat의 정상적인 사용 방법은 <그림 9>에서와 같이 클라이언트가 서버에 “bird”라는 내용(payload)을 보내면서 payload의 크기가 4byte라고 알려주면, 서버는 응답시 클라이언트로부터 받은 4byte의 “bird”를 되돌려줌

![image](https://user-images.githubusercontent.com/62640332/136651690-24fa9fc4-ccea-4a1d-befa-bac296fa962d.png)

![image](https://user-images.githubusercontent.com/62640332/136651711-51e88085-b859-42e3-9e38-8a575264a405.png)

- Heartbleed 취약점에 노출된 경우, SSL 인증서를 무효화(revoke)하고 재발행해야 함



<br>
<br>

***
#### ㅁ Insecure Deserialization(안전하지 않은 역직렬화)
- 직렬화(Serialization) : 서로간에 원활한 통신을 위하여 객체를 직렬 화하여 전송 가능한 형태로 변환
- 역직렬화(Deserialization) : 직렬화된 파일 등을 역으로 직렬화하여 다시 객체의 형태로 변환
(저장된 파일을 읽거나 전송된 Stream 데이터를 읽어 원래 객체의 형태로 복원)
- 공격의 발생 원인
  >1. 애플리케이션 및 API가 공격자의 악의적이거나 변조된 객체를 역직렬화하면 취약해질 수 있습니다.
  >2. 공격자가 애플리케이션 로직을 수정하거나 애플리케이션에 사용 가능한 클래스가 있는 경우 임의의 원격코드를 실행하여 역직렬화 중이나 이후에 동작을 변경할 수 있습니다. 
  >3. 기존 데이터 구조가 사용되지만 내용이 변경되는 일반적인 데이터 변조 공격

- 대응 방법 
  > 1. 신뢰할 수 없는 출처로부터 직렬화된 객체 차단
  > 2. 원시 데이터 유형만을 허용하는 직렬화 매체를 사용
  > 3. 악성 객체 생성이나 데이터  변조를 방지하기 위해 직렬화된 객체에 대한 디지털 서명과 같은 무결성 검사를 구현
  > 3. 객체 생성 전 코드가 일반적으로 정의하는 클래스 집합을 기대하므로 역 직렬화에 대한 엄격한 형식 제약조건 적용
  > 4. 역직렬화 하는 컨테이너 또는 서버에서 들어오고 나가는 네트워크 연결을 제한하거나 모니터링 필터링하여 차단


<br>
<br>

#### ㅁ CSRF 공격(Cross Site Request Forgery)
:웹 어플리케이션 취약점 중 하나로 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격입니다.   
CSRF를 통해 해커는 희생자의 권한을 도용하여 중요 기능을 실행하는 것이 가능   
CSRF 공격이 이뤄지려면 다음 조건이 만족되어야 합니다.    

>위조 요청을 전송하는 서비스(페이스북)에 희생자가 로그인 상태       
희생자가 해커가 만든 피싱 사이트에 접속      
   
ㅁ대응 방법  

1. Referrer 검증      
: Back-end 단에서 request의 referrer를 확인하여 domain (ex. *.facebook.com) 이 일치하는 지 검증하는 방법   
2. Security Token 사용       
   :사용자의 세션에 임의의 난수 값을 저장하고 사용자의 요청 마다 해당 난수 값을 포함 시켜 전송시킵니다. 이후 Back-end 단에서 요청을 받을 때마다 세션에 저장된 토큰 값과 요청 파라미터에 전달되는 토큰 값이 일치하는 지 검증하는 방법
3. Double Submit Cookie 검증      
   :웹브라우저의 Same Origin 정책으로 인해 자바스크립트에서 타 도메인의 쿠키 값을 확인/수정하지 못한다는 것을 이용한 방어 기법입니다.   
   스크립트 단에서 요청 시 난수 값을 생성하여 쿠키에 저장하고 동일한 난수 값을 요청 파라미터(혹은 헤더)에도 저장하여 서버로 전송합니다.    
   서버단에서는 쿠키의 토큰 값와 파라미터의 토큰 값이 일치하는 지만 검사하면 됩니다.    
   서버에 따로 토큰 값을 저장할 필요가 없어 위에서 살펴본 세션을 이용한 검증보다 개발 공수가 적은 편입니다.    
   피싱 사이트에서는 도메인이 달라 facebook.com 쿠키에 값을 저장하지 못하므로 (조금 전에 언급한 Same Origin 정책) 가능한 방어 기법

***

<br>
<br>


#### ㅁ SSRF(Server-side Request Forgery)    
:CSRF가 클라이언트 측에서 위조된 요청을 보내는 거라면 SSRF는 서버 측에서 위조된 요청을 보내도록 하는 취약점    
SSRF 취약점을 이용해서 공격자는 웹앱과 같은 서버측 프로그램이 임의의 주소로 HTTP 요청을 보내게 된다.     
그러면 일반적으로 사용자들이 접근할 수 없었던 서버 내부 자원에 접근해서 API key와 같은 중요 데이터가 유출되거나 내부 네트워크 스캔 그리고 경우에 따라 임의 코드 실행이나 임의 파일 쓰기 등의 허가받지 않은 행위가 가능할 수 있다.    
> \# Blind SSRF
사용자의 요청에 대해 서버에서 내부적으로 요청은 발생하지만 그 응답이 사용자에게까지 가지 않아서 확인을 할 수 없는 형태의 SSRF이다. 이런 경우에는 공격자의 서버로 요청을 보내 공격자의 요청이 타겟 서버로부터 오는지를 확인하는 방식으로 확인을 할 수 있다. Blind SSRF는 중요 정보를 유출하기는 힘들지만 내부 네트워크에 있는 취약한 서비스에 1-day 취약점 payload를 보내서 exploit 할 수도 있고 공격자의 서버로 요청을 보내서 타겟 서버의 http client를 공격하는 응답을 보내서 RCE를 시도할 수도 있다. 

1. 사용자의 입력값으로 URL을 받아서 처리하는 서비스의 경우 잠재적으로 SSRF 취약점이 존재

2.  Referer 헤더의 링크를 통해서 정보를 수집하고 통계에 이용하는 경우가 있다. Referer 링크에서 요청하고 meta 데이터들을 읽거나 페이지를 읽어서 내부 데이터로 이용하는 경우가 있는데 이 때도 역시 SSRF는 발생 가능하다.

3.  데이터를 XML로 전송할 경우 XXE Inejction을 통해서 SSRF를 트리거할 수도 있다

4.  Open Redirection 취약점이 있을 때 경우에 따라 SSRF를 트리거할 수 있다.

ㅁ 대응방법

1. 입력값을 블랙리스트 방식으로 필터링

2. 입력값을 화이트리스트 방식으로 필터링한다. (허용된 도메인과 URL에 대해서만 허용)

3. URL 검사할 때 단순히 문자열 포함여부를 검사하지 않고 정규식을 활용하며 정확히 host domain을 검사하도록 하고 @나 #기호를 이용해 우회할 수 없도록 기능을 막거나 필터링

4. 서버 내부 정보나 내부 네트워크의 정보가 빠져나가지 않도록 비록 내부 네트워크에서의 접근이라도 중요한 데이터일 경우 추가 인증을 받도록 해서 SSRF 취약점이 있어도 피해가 발생하지 않도록 한다.

5. 요청을 처리하는 서버와 중요 정보가 있는 내부망을 분리

6. 요청한 URL에 대한 응답 값이 예상한 값인지를(응답이 이미지인지 동영상인지 등) 검사할 수도 있다. 하지만 이 경우 404, 403과 같은 에러코드가 응답되면서 서버 내부 ip 혹은 포트스캔에 이용될 수 있으니 URL에 대한 추가적인 필터링이 필요

7. http나 https를 제외하고 사용하지 않는 URI scheme은 비활성화하거나 필터링한다.


<br>
<br>

***

#### ㅁ Shell shock

: 리눅스 계열 OS에서 주로 사용하는 GNU Bash에서 공격자가 원격에서 악의적인 시스템 명령을 실행 할 수있는 취약점.

취약점이 발생한 부분은 Bash쉘이 제공하는 함수 선언 기능.
"0 {"로 시작하는 문자열을 시스템 환경변수에 저장하면 동일한 이름을 가진 함수로 선언된다.

하지만 함수 선언문 끝에 임의의 명령어를 추가로 삽입할 경우, Bash가 함수문에서 처리를 멈추지 않고 추가로 삽입한 명령어를 계속 실행 시키기 때문에 문제가 발생.

![image](https://user-images.githubusercontent.com/62640332/136659841-85d9782a-e7a1-44ae-a98e-b326fda65daf.png)

Bash의 소스코드 분석 시, evalstring.c 파일 내에 정의되어 있는 parse_and_execute() 함수에서 Bash에 전달된 명령어를 처리하여 실행

명령어 문자열을 처리하는 과정에서 반복문(while)을 사용하는데, 함수 선언문 뒤에 명령어가 삽입된 것을 확인하고 반복문을 종료시키는 코드가 없음.    
따라서 함수 선언문의 끝까지 처리한 뒤에도 반복문이 계속 실행되어 삽입된 명령어가 실행.

![image](https://user-images.githubusercontent.com/62640332/136659878-3186c0d7-779e-468f-8104-eaa5dd48d3f5.png)

<mark>만약 외부로부터 환경변수를 전달받아 Bash 쉘을 통해 명령어를 실행하는 서버가 존재하면, 공격자는 함수 선언문 뒤에 임의의 명령어를 삽압시켜 해당 프로세스의 권한으로 실행 시킬 수 있음.</mark>

직접적으로 명령어 주입이 가능한 취약점이기에 ASLR(Address Space Layout Randomization) 등의 OS 보호 매커니즘에 전혀 영향을 받지 않아 공격 성공률이 매우 높음.
![image](https://user-images.githubusercontent.com/62640332/136659923-4805defc-9257-4313-b2cc-006fd927b416.png)

ㅁ 대응 방법       

1. Bash 업데이트               
2. 사용하지 않는 CGI 페이지 삭제 또는 관련 서비스 중지.              
3. 네트워크 탐지룰 설정.          
  ***

<br>
<br>

#### ㅁ XSS(Cross Site Scripting)

\#HTTP 프로토콜

> 웹 서버와 클라이언트간 서버에 저장된 웹 문서(일반적으로 HTML, 스크립트, 이미지(.gif, .jpeg)등을 클라이언트로 전달하기 위한 표준규약.

> 먼저 클라이언트(브라우저)는 서버로 헤더 정보를 포함하여 관련 정보를 요청(request)하면, 웹 서버는 클라이언트의 요청을 분석하여 요청한 자원 데이터 및 헤더를 포함하여 클라이언트로 응답(response)을 보냄.

:XSS는 애플리케이션에서 브라우저로 전송하는 페이지에서 사용자가 입력하는 데이터를 검증하지 않거나, 출력 시 위험 데이터를 무효화 시키지 않을 때 발생

공격자가 의도적으로 브라우저에서 실행될 수 있는 악성 스크립트를 웹 서버에 입력 또는 이것을 출력시 위험한 문자를 중성화시키지 않고 처리하는 애플리케이션의 개발 과정에서 발생.

XSS는 일반적으로 자바스크립트에서 발생하지만, VB 스크립트, ActiveX 등 클라이언트에서 실행되는 동적 데이트를 생성하는 모든 언어에서 발생 가능.

XSS공격 종류
- 저장 XSS Attack 
> 접속자가 많은 웹 사이트를 대상으로 공격자가 XSS 취약점이 있는 웹 서버에 공격용 스크립를 입력시켜 놓으면, 방문자가 악성 스크립트가 삽입되어 있는 페이지를 읽는 순간 방문자의 브라우저를 공격하는 방식.

1. 웹 애플리 케이션 취약점이 있는 웹 서버에 악성 스크립트를 영구적으로 저장해 놓는 방법.

2. 이 때 웹 사이트의 게시판, 사용자 프로필 및 코멘트 필드 등에 악성 스크립트를 삽입해 놓으면, 사용자가 사이트를 방문하여 저장되어 있는 페이지에 정보를 요청할 때, 서버는 악성 스크립트를 사용자에게 전달하여 사용자 브라우저에서 스크립트가 실행되면서 공격한다.

3. 가장 일반적인 방법은 게시판 같은 곳에 HTML 문서에 \<script>를 이용하여 이 스크립트 태그 안에 악성 스크립트를 저장하는 방식.

4. 저장 XSS는 공격자 입장에서 사용자들이 많이 방문하는 사이트가 공격 대상으로 가장 적합한 곳.

<br>

### 반사 XSS Attack

> 악성 스크립트가 포함된 URL을 사용자가 클릭하도록 유도하여 RUL을 클릭하면 클라이언트를 공격.
1. 웹 애플리케이션의 지정된 변수를 이용할 때 발생하는 취약점을 이용하는 것으로, 검색 결과, 에러 메시지 등 서버가 외부에서 입력받은 값을 받아 브라우저에게 응답할 때 전송하는 과정에서 입력되는 변수의 위험한 문자를 사용자에게 그대로 돌려주면서 발생.

![image](https://user-images.githubusercontent.com/62640332/136660269-f6bc4b8b-8d4c-47c8-98b8-28a844daa650.png)

2. 일반적으로 서버에 검색 내용을 입력하면, 검색 결과가 있는 경우에는 결과 값을 사용자에게 전달 하지만 서버에서 정확한 결과가 없는 경우 서버는 브라우저에 입력한 값을 아래의 <그림>과 같이 그대로 HTML문서에 포함하여 응답.

![image](https://user-images.githubusercontent.com/62640332/136660274-bbebd210-6f1a-4d4d-afdc-1319ec2cad1b.png)


4. 이 경우 HTML페이지에 포함된 악성 스크립트가 브라우저에서 실행.   
> So, 사용자가 서버로 입력 한 값을, 서버는 요청한 사용자의 브라우저로 악성스크립트를 반사시킴.   

5. 반사 XSS공격은 주로 사용자에게 악성 URL을 배포하여 사용자가 클릭하도록 유도하여 클릭한 사용자를 바로 공격.   
> So, 사용자는 악성 스크립트가 포함된 링크를 클릭한 순간 바로 악성 스크립트가 사용자의 브라우저에서 실행.   

6. 반사 XSS공격은 이메일 메시지 또는 다른 웹 사이트와 같이 다양한 경로로 피해자 시스템에게 전달.   
7. 

<br>
<br>

### DOM 기반 XSS Attack

> DOM환경에서 악성 URL을 통해 사용자의 브라우저를 공격.       
1. DOM(Document Object Model)이란 W3C 표준으로 HTML 및 XML 문서에 접근방법을 표준으로 정의하는 문서객체 모델.                             
> W3C에서는 DOM을 '프로그램 및 스크립트가 문서의 컨텐츠, 구조 및 형식을 동적으로 접근 및 업데이트 할 수 있도록 하는 언어 중립적인 인터페이스이다' 라고 정의.                             
> DOM은 HTML문서를 계층적으로 보면서 컨텐츠를 동적으로 변경할 수 있다.                         
2. DOM 기반 XSS 공격은 피해자의 브라우저가 HTML페이지를 구문분석할 때마다 공격 스크립트가 DOM 생성의 일부로 실행되면서 공격.                                          
3. 페이지 자체는 변하지 않으나, 페이지에 포함되어 있는 브라우저 측 코드가 DOM환경에서 악성코드로 실행.                       
4. 저장 XSS 및 반사 XSS공격의 악성 페이로드가 서버 측 애플리케이션 취약점으로 인해, 응답 페이지에 악성 스크립트가 포함되어 브라우저로 전달되면서 공격하느 것인 반면,                    
 DOM 기반 XSS는 서버와 관계없이 브라우저에서 발생하는 것이 차이점.                       
6. 일반적으로 DOM 기반 XSS 취약점은 브라우저를 대상으로 조작된 URL을 이메일을 통해 사용자에게 전송하면, 이 URL링크를 클릭하는 순간 공격 피해를 입게 됨                           

ㅁ 대응 방법

ⅰ] 입,출력 값 검증 및 무효화    

1. XSS 취약점을 근본적으로 제거하기 위해서는 스크립트 등 해킹에 사용될 수 있는 코딩에 사용되는 입력 및 출력 값에 대해서 검증하고 무효화시켜야함. 

2. 입력 값에 대한 유효성 검사는 데이터가 입력되기 전에 가능하면, 입력 데이터에 대한 길이, 문자, 형식 및 사업적 규칙 유효성을 검사.

3. 출력값을 무효화하기 위해서는 XSS공격은 기본적으로 \<script>태그를 사용하기 때문에 XSS공격을 차단하기 위해 태그 문자(<,>) 등 위험한 문자 입력 시 문자 참조(HTML entitiy)로 필터링하고, 서버에서 브라우저로 전송 시 문자를 인코딩.

4. 서버에서 브라우저로 전송 시 무자를 인코딩.               
\# HTML 문자 참조 : ASCII문자를 동일한 의미의 HTML문자로 변경하는 과정.         
> ex) 문자 "<"는 동일한 의미의 HTML "&lt;"로 변경한다. HTML 엔터티는 대부분의 인터프리터(특히, 브라우저)에서 특수한 의미를 가지지 않으며, 단순한 문자로 처리됨.         
5. 이렇게 인코딩하면 사용자는 \<script>가 \<script>로 보이지만 HTML 문서에서는 &lt;script&gt;로 나타나서 브라우저에서 일반 문자로 인식하고 스크립트로 해석되어 실행되지는 않는다.      
  
![image](https://user-images.githubusercontent.com/62640332/136660463-29d33149-f7af-4e5d-b4e4-1d9dd3418dac.png)

![image](https://user-images.githubusercontent.com/62640332/136660478-adc37af3-c4f0-4b80-986b-f705ed752e54.png)

ⅱ] 보안 라이브러리

1. AntiXss: MS 에서 공개용 XSS 취약점 예방 라이브러리
2. OWASP ESAPI 라이브러리: OWASP는 포괄적인 애플리케이션 보안을 위해 웹 응용 취약점을 대응할수 있는 오픈소스  ESAPI를 개발하여 제공

ⅲ] 브라우저 확장 프로그램

1. NoScript: 모지갈 기반의 브라우저에서 실행되는 오픈소스 확장프로그램으로 화이트 리스트 기반으로 신뢴된 사이트의 동적 스크립트만 브라우저에서 실행하도록함.


<br>
<br>


***
### ㅁ SQL Injection
:웹 어플리케이션에서 데이터베이스로 전달되는 SQL쿼리 값을 변조 및 삽입히여 비정상적인 방법으로 데이터베이스에 접근하는 공격을 의미
 이러한 공격을 통해 발생될 수 있는 취약점은 인증우회(계정 및 암호없이 로그인), 시스템 명령어 삽입(저장 프로시저를 악용한 OS 명령어 삽입 등), 웹쉘 생성등이 있다.

- 논리적 에러를 이용하는 SQL Injection     
> or 1=1 등의 논리적 에러를 발생시킬 수 있는 패턴을 이용한 인증우회 기법.
특히 에러가 발생되는 사이트에서는 에러정보를 이용하여 데이터베이스 및 쿼리 구조 등의 정보를 추측.    
ex) SELECT * FROM Users WHERE Username='$username' AND Password='\$password'    
외부에서 입력될 수 있는 계정(\$username)과 암호(\$password)에 참 조건(or 1=1)을 수행하는 문장을 삽입하여 계정과 암호 없이도 로그인 우회가 가능.     
ex)SELECT * FROM Users HERE Username='1' or '1'='1' AND Password='1' or '1'='1'   

- Union SQL Injection
>UNION은 2개 이상의 쿼리를 요청하여 결과를 얻는 SQL 연산자이며,    
공격자는 이를 악용하여 원래의 요청에 한 개의 추가 쿼리를 삽입하여 정보를 얻어내는 방식.    
ex)id=5라는 1개의 쿼리와 테이블 정보가 들어있는 information_schema.tables를 얻으려는 추가 쿼리가 합쳐진 공격패턴     
ex)http://www.site.com/news.php?id5 union all select 1,table_name,3 from information_schema.tables     

- Blind SQL Injection
> 악의적인 문자열 삽입 대신 쿼리(참 혹은 거짓)에 따라 정보를 취득하는 기법.
why use?

에러가 발생되지 않는 사이트에서 위의 기법들을 사용할 수가 없기 때문에 공격을 통해 정상적인 쿼리가 수행되는지 혹은 쿼리가 수행되지 않아 쿼리 결과가 없느지를 통해 판단할 수 있다.

ex) id=5 다음에 and 1=1을 삽입하였고 이는 where id=5 and 1=1로 처리될 것이다.

id=5(참) and 1-1(참)이기 대문에 page.php?id=5 입력한 것과 동일한 결과 페이지가 제공 될 것이다.

http://ww.xxx.com/page.php?id= and 1=1 (참 조건)

그러나 and 1=2를 삽입한 경우, 

id=5(참)와 1=2(거짓)의 거짓조건으로 인해 정상적인 쿼리가 수행되지 않아 화면에 결과가 출력되지 않을 것이다.

http://www.xxx.com/page.php?id=5 and 1=2 (거짓 조건)


- 저장 프로시저를 이용하는 Stored Procedure SQL Injection
> 저장 프로시저는 운영상 편이를 위해 만들어둔 SQL 집합형태이며, 
특히 MS SQL에서 사용할 수 있는 xp_cmdshell은 윈도우 명령어인 netstat -an(네트워크 상태정보 제공)을 삽입하고 있다.
ex)http://www.site.com/member/checkid.asp?id=';CREAT.....r.dbo.xp_cmdshell%20' netstat%20-an';

- Blind SQL Injection
> 쿼리 결과를 특정시간만큼 지연시키는 방법을 이용하는 기법.
Blind 기법과 마친가지로 에러가 발생되지 않은 조건에서 사용하는 기법.
ex)MySQL에서 Sleep() 함수를 이용하여 5초 후에 쿼리 결과를 얻도록 공격문자열을 삽입
만약 5초 후에 쿼리 결과가 화면에 출력도니다면 취약저이 있다고 판단 가능.
http://testphp.vulnweb.com/listproducts.php?cat=1 AND SLEEP(5) 

- SQL Injection
> GET, POST 요청필드, HTTP 헤더 값, 쿠키값 등에 특수문자(싱글 쿼트( ' ) 혹은 세미콜론( ; )) 삽입 시, SQL 에러가 발생된다면 취약점이 있다고 판단 가능.

<br>
<br>

***

#### ㅁ - XXE(XML eXternal Entity, XML 외부 엔티티)
  XXE 취약점 : XML 타입의 데이터 웹 요청을 통해 전송, 서버에서 XML 외부 엔티티 처리 가능하게 설정된 경우 발생

1. 사용자가 웹 애플리케이션으로 전달되는 XML 데이터를 직접 업로드/수정 가능
2. 공격자는 외부 엔티티를 참조하는 XML 데이터 전송
3. 파일과 같은 서버 내부의 정보 탈취/DOS/SSRF등의 공격 수행

- XML 외부 엔티티 선언 형태

> \<!DOCTYPE foo [
\<!ENTITY xxe SYSTEM "file:///etc/passwd">
\]>

DOCTYPE 선언을 한 다음 ENTITY 태그 이용, xxe라는 외부 엔티티 선언
선언된 외부 엔티티는 프로그래밍 시 변수 참조 처럼 XML 내부에서 참조 가능
xxe 엔티티를 참조하면 xxe 값인 SYSTEM 키워드로 지정된 /etc/passwd 파일 참조
file:// 대신 http://를 사용하여 외부 리소스 참조도 가능

대응 방법
1. 원천적인 대응 방법 : 외부 엔티티 참조 기능이 필요하지 않은 경우 DTDs나 외부 엔티티 관련 설정을 비활성화
  -> 비활성화 방법은 프로그래밍 언어나 XML 파서의 종류에 따라 다름(OWASP 문서 링크 참조)
2. 시스템 운영자 or 보안 관리자 : ENTITY 태그가 요청 메시지를 통해 전달되는 것이 확인되면 주의
  -> 원래 의도된 요청인지 확인 필요
3. 서비스 중인 웹 애플리케이션에서 XML 외부 엔티티 기능 필요 X -> 웹 방화벽 등 장비를 이용하여 해당 메시지 차단


<br>
<br>

#### ㅁ XML 이란?   

- XML = Extensible Markup Language = 다른 특수한 목적을 갖는 마크업 언어를 만드는데 사용하도록 권장하는 다목적 마크업 언어   

- 마크업 언어 = 태그 등을 이용하여 문서나 데이터의 구조를 명기하는 언어의 한가지   

- 주로 다른 종류의 시스템, 특히 인터넷에 연결된 시스템끼리 데이터를 쉽게 주고 받을 수 있게 하여 HTML의 한계를 극복할 목적으로 만들어진 언어


- XML 핵심 요소 (참고 : http://tcpschool.com/xml/xml_basic_structure)   
: XXE 공격에 대해 알기 위해서는 먼저 XML이 무엇인지, 어떻게 구성되어있는지를 알아야 한다.   
\# 더 자세한 사항은 ( https://ko.wikipedia.org/wiki/XML )를 참고



- 프로세서(processor)와 애플리케이션(application)   
> 프로세서는 마크업을 분석하고 구조화된 정보를 애플리케이션에 넘긴다.   
> 프로세서는 흔히 XML parser라 불린다.

- 마크업(markup)과 내용(content)
:XML 문서를 구성하는 문자들은 마크업과 내용으로 나뉜다.   
일반적으로 마크업을 구성하는 문자열 아래와 같다. (마크업이 아닌 문자열은 내용)
 (1) 문자 [ < ]로 시작하여 문자 [ > ]로 끝
 (2) 문자 [ & ]로 시작하여 문자 [ ; ]로 끝

- CDATA 절에서 <![CDATA[ 와 ]]> 는 마크업으로 분류되고, 그들 사이의 텍스트는 내용으로 구분된다. 가장 바깥 엘리먼트의 앞과 뒤의 공백(whitespace)은 마크업으로 분류


- 태그(tag) : [ < ] 로 시작하여 [ > ]로 끝나는 마크업 구조

 (1) 시작 태그 : \<section>

 (2) 끝 태그 : \</section>

 (3) 빈 엘리먼트 태그 : \<line-break />

- 엘리먼트(element) : 문서의 논리 요소

- 시작 태그로 시작하여 짝이 되는 끝 태그로 끝

- 순서 : [시작태그] [내용(마크업 포함)] [종료태그]

 ex) <Greeting>Hello, World</Greeting> 

- 빈 엘리먼트 태그

 ex) <line-break />



- 애트리뷰트(Attibute) : 이름/값 짝으로 이루어진 마크업 구조

 - 시작 태그 또는 빈 엘리먼트 태그 속에 위치

 - 아래의 경우 엘리먼트 img는 src와 alt의 두 애트리뷰트를 갖는다.



- XML 선언 : XML 문서는 아래와 같이 자신에 대한 정보 일부를 선언하는 것으로 시작할 수 있다.

\<?xml version="1.0" encoding="UTF-8" ?>



ㅁ XXE 동작 방식

- XXE(XML External Entity) 공격은 취약하게 설정된 XML parser에 의해 external entity를 참조하는 XML input을 처리하였을 때 발생한다.

- XML 1.0 표준은 XML 문서의 구조를 정의하고 있다. 그 표준은 몇몇 타입의 저장 단위를 모아 entity라는 컨셉으로 정의한다. 여기에는 일부 다른 entity 타입이 있는데 선언된 시스템 identifier를 통해 로컬 혹은 원격지의 컨텐츠에 접근이 가능한 external entity라는 것이 있다.

<br>
<br>

***
#### ㅁ 파일 인클루전(file inclusion) 공격
:PHP 애플리케이션을 대상으로 발생, PHP의 인클루드 기능을 이용하는 공격
  - 인클루드 기능 : include라는 함수를 이용, 다른 파일을 소스코드에 직접 포함시킬 수 있는 기능
    -> 인클루드할 파일을 외부 사용자가 지정 가능한 경우 파일 인클루전 취약점 존재!
    => 공격자가 본인이 원하는 파일 인클루드시킬 수 있다!
    파일 인클루전 공격 개요

- 공격자가 인클루드 할 수 있는 파일이 각각 호스트 내부/외부의 파일인지에 따라

  1) 로컬 파일 인클루전(Local File Inclusion, LFI)

  2) 리모트 파일 인클루전(Remote File Incluson, RFI)

  두 종류로 구분.

  -> 외부의 파일도 원격으로 인클루드할 수 있는 RFI 공격이 더 심각한 공격임

 

- RFI 공격이 이루어지는 경우:

  1. 정상적인 상황에서 웹 애플리케이션이 file.php를 인클루드     
  
  2. flie.php가 웹 요청의 page 파라미터를 통해 지정됨 => 문제 발생      

  3. 공격자가 file.php 대신 자신이 관리하는 hacker.com으로부터 악성 코드 bad.php를 인클루드할 것을 지정        
               
  4. 웹 애플리케이션이 입력값 검증 수행 X => bad.php 파일을 인클루드하여 실행하게 됨              
              
- 웹 애플리케이션이 http://와 같은 문자열의 입력을 차단하여 RFI에 대해 방어                  
                
  -> LFI 공격 발생 가능성 여전히 존재

  => 공격자가 외부의 파일 대신 서버 호스트 내부의 파일 인클루드 시도

    ../(상위 디렉터리 경로 의미)와 같은 문자열을 이용 -> 현재의 웹페이지의 경로에서 벗어날 수 있게 됨
    -> ../../../../처럼 여러번 반복 => 루트 디렉터리까지 이동 가능 => 루트 디렉터리 아래 모든 경로 지정 가능

    => 위와 같은 공격 기법을 디렉터리 트래버설 공격이라고 함

<br>

ㅁ 대응 방법                 
        
1. 가장 좋은 방법은 외부 사용자가 입력한 파일 이름을 인클루드에 사용하지 않는 것!           
   
2. 어쩔 수 없이 외부에서 파일 이름을 입력받을 경우 그 입력값을 검증받아야 함(2장 참고)   
                          
3. 가급적 화이트 리스트 검증 사용, 인클루드가 필요한 파일 이름의 목록을 작성, 해당 파일만 허용, 나머지 전부 차단                   
 
4. 블랙리스트 검증의 경우 http://, https://와 같은 프로토콜 관련 문자열 or ../ 같은 디렉터리 트래버설 공격을 위한 문자열 차단                                     

<br>
<br>


> 해당 서버로 부터 IP를 받아야 하는 정상적인 클라이언트가 IP를 할당 받을 수 없다.   


<br>
<br>


***
## Reflection Amplification State
***

#### DNS 증폭 공격(Amplification Attack)   
: 출발지 IP 주소를 조작하여 DNS 요청(DNS query)에 대한 응답(DNS response)이 조작된 IP 주소(Victim)로 전송 되도록 하는 공격 방법이다.      
 조작하여 공격이 가능한 이유는 기본적으로 DNS 패킷에는 인증 절차가 존재하지 않기 때문이다.

 증폭을 위해서 공격자는 Open DNS Resolver 서버를 이용하고 DNS Query 의 Type 을 "Any" 로 설정한다.   

 ▶ Open DNS Resolver 서버
Open DNS Resolver 서버는 재귀적 질의(Recursive Query) 가 설정되어 있는 서버를 말한다. 재귀적 질의란 요청한 도메인 이름이 자신의 서버에 없을 경우 상위 DNS 서버에 요청을 주고 이러한 과정을 반복함으로써 최종 도메인 이름에 대한 처리를 해주는 것을 의미한다. DNS 쿼리와 응답의 크기는 불균형적이며, 쿼리에 대한 응답은 원래 쿼리와 응답 모두를 포함하기 때문에 응답 패킷이 항상 쿼리 패킷보다 크게 되어 증폭된다. 예를 들어, DNS 네임 서버가 60 바이트 EDNS 쿼리(EDNS = Extended DNS) 를 받으면 그것에 대한 응답은 122 바이트 A RR 과 4000 바이트 TXT RR, 222 바이트 SOA RR 을 포함할 수 있다. 이는 최대 쿼리 보다 응답이 73% 커지도록 만들어 준다.

▶ DNS Query Type "Any"
DNS Query 의 Type 을 "Any" 로 설정하게 되면 다양한 Type 의 레코드를 모두 요청하게 되므로 요청한 쿼리 패킷보다 크게 증폭된다.

결국, 재귀적 질의 와 ANY 타입의 레코드를 결합해 DNS 서버에 초당 수백 건의 DNS Query 를 보내게 되면 인증 절차가 없기 때문에 수십 Gbps 의 응답 트래픽을 발생시키게 된다.


ㅁ 대응 방법   
- 가장 기본적인 조치로 DNS 서버를 최신 버전으로 업데이트한다.  
   
- 가장 기본적인 방어 방법은 공격에 사용되고 있는 내부 DNS 서버에서 Any 쿼리를 못하게 설정하는 것이다. 혹은 DNS 를 사용하지 않고 있다면 서비스를 Down 시켜야 한다. 
    
- 출발지가 변조되었기 때문에 출발지 IP 를 방화벽에서 필터링하여 막는 것은 불가능하다. 다만 공격자가 공격 설정 시 특정 포트를 지정하였다면 변조되어 쿼리 하는 출발지의 포트를 필터링하여 쿼리를 막을 수 있다.
  
- 재귀적 질의를 사용하지 않도록 DNS 서버의 설정을 변경한다.
  
- 일반적으로 DNS 서버는 내부에서만 사용하므로 내부 IP 에서 요청한 DNS Query 에 대해서만 응답하도록 DNS 서버의 설정을 변경한다.


<br>
<br>

***
#### NTP 증폭 DRDoS 공격(Amplification Attack )  
---

- UDP프로토콜 사용] DNS, NTP, SNMP, CHARGEN 등의 서비스를 이용한 DRDoS 공격은   
크게 반사(Reflection)와 증폭(Amplication) 공격 형태로 나타난다.   

공격자는 출발지IP를 공격대상IP로 위조하여 취약한 서비스를 사용하는 서버에 대규모 메시지를 보내고,

​서버는 요청에 대한 응답메시지를 공격대상 IP에 반사 시도한다. 이때 반사된 응답메시지는 대량의 트래픽으로 증폭되어 공격 대상에게 전달된다.

- TCP프로토콜 사용] 공격자는 송신지 IP를 공격대상의 IP로 위조한 후 대량의 SYN 패킷을 반사서버로 전송한다.  

SYN패킷을 받은 장비는 위조된 출발지 IP로 정상적인 SYN+ACK 패킷을 전송한다.

공격대상 서버는 다수의 응답을 반사서버로부터 받아 서비스 거부상태가 된다.

​일반 DoS 공격과의 차이점은 공격 근원지를 파악하기 어렵다는 것이다.   
출발지 IP를 변조하고 공격 트래픽이 수많은 반서서버를 경유하므로 공격의 근원지를 파악하는 것이 매우 어렵다.​

또한 좀비 PC의 공격 트래픽 효율이 증가한다. DRDoS에 사용되는 반사서버는 SYN+ACK패킷에 대한 응답이 없을 경우 일정횟수 재전송을 수행하기 때문에 공격자가 전송하는 SYN패킷보다
몇 배 많은 SYN+ACK 패킷이 공격대상서버에 전송된다.

ㅁ 대응방법

- NTP 버전을 확인하고 업그레이드하기.   
> ntpd -version

​- monlist 비활성화 하기   
> ntpd.conf disable monlist​

- 원격으로 monlist 지원여부 확인.   
> ntpd -c monlist ip주소​

- ntp서버 트래픽 유입을 제한하는 방화벽 설정   
> iptables -A OUTPUT -p udp --sport 123 -j DROP​




<br>
<br>


***
#### SSDP Amplification DDoS
: SSDP (Simple Service Discovery Protocol) 공격은 증폭 된 양의 트래픽을 대상 희생자에게 보내고 UPnP (범용 플러그 앤 플레이) 네트워킹 프로토콜을 악용하여 반영하는 반사 기반의 분산 서비스 거부 (DDoS) 공격입니다 대상의 인프라 및 웹 리소스를 오프라인 상태로 만듭니다.

- SSDP (Simple Service Dicovery Protocol)
: 네트워크 서비스나 정보를 찾기 위해서 사용하는 네트워크 프로토콜. 일반 거주와 소규모 사무 환경에서 UPnP를 위한 기본적인 프로토콜로 사용하고 있음 . (SSDP 는 UPnP의 표준)   

- UPnP (Universal plug and play)
: 홈 네트워크에 있는 네트워크 장치들이 서로 연동될 수 있도록 하는 범용 표준 프로토콜. 

정상적인 상황에서 SSDP 프로토콜은 UPnP 장치가 네트워크상의 다른 장치에 자신의 존재를 브로드 캐스트하도록 허용하기 위해 사용됩니다.

공격자는 UPnP 장치들을 찾아 리스트화 하고 대상자의 IP로 스푸핑된 UDP 패킷을 만들어 가능한 많은 데이터를 요청하는 내용을 담아 각 장치로 전송합니다. 대상자는 각 장치로부터 오는 증폭된 트래픽을 한꺼번에 받게 됩니다. 


<br>
<br>


***
#### VSE Query Flooding
: TSource Engine Query를 많은 요청으로 처리하여 모든 서버를 처리 할 수 ​​없도록함으로써 게임 서버에 대한 거부 공격을 발생 시키도록 설계되었습니다.

밸브 소스 엔진 플러드는 서버에 대해 사용 가능한 리소스를 소비하는 데 사용되는 UDP (증폭) 공격입니다. 공격은 TSource 엔진 쿼리 요청을 게임 서버에 보내도록 설계되었으므로 서버가 모든 요청을 처리 할 수없고 게임 서비스 거부를 만드는 많은 요청을 처리합니다. 이 유형의 공격은 게이머 시장에만 적용됩니다. Mirai는 서비스로 설계 되었기 때문에 게이머가 경쟁 우위, 경쟁 또는 복수에 대한 지연 또는 중단을 유발할 수 있다는 점이 매력적입니다.

<br>
<br>

***
#### GRE Flooding
: GRE 프로토콜을 이용해 특정사이즈의 패킷을 지속적으로 발생시켜 서버자원의 고갈을 유도한다.
GRE 프로토콜은 공격시 encapsulation을 통해 대량의 payload를 전송 가능하고 , 타겟서버는 IP defragmentation 과정에서 자원의 고갈이 발생 할 수 있다. 

- GRE Protocol    
GRE (Generic Routing Encapsulation)는 IP 네트워크에서 가상 점대 점 링크 내에 다양한 네트워크 계층 프로토콜을 캡슐화 할 수있는 터널링 프로토콜 
***



<br>
<br>

#### Tsunami Syn Flooding
: 기존 SYN flood Attack은 패킷 당 40-60bytes의 트래픽을 유발하는데 반해, Tsunami SYN-Flood Attack은  패킷 당 1000bytes의 트래픽을 유발함

이러한 DDoS 공격의 유형은 UDP가 아닌 TCP 프로토콜을 사용하여 공격함
- 일반적으로 SYN 패킷은 TCP 3way handshake과정에서 생성되는 메시지이며 해커들은 일반적인 SYN 패킷에 25배(최대 1000bytes)의 크기로 패킷 데이터양을 추가하는 방식으로 공격을 수행함

\# TCP 3way handshake: TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정

공격을 위해 봇넷(Botnet)을 이용하였으나 “공격자들은 트래픽이 발생하는 기계를 완벽히 제어할 수 없었으며 더 많은 봇(bots)을 트래픽에 덧붙여 공격한다.”라고 Radware 영국 지사의 Crawley가 설명함

\# 봇넷(Botnet):스팸메일이나 악성코드 등을 전파하도록 하는 악성코드 봇(Bot)에 감염되어 해커가 마음대로 제어할 수 있는 좀비PC들로 구성된 네트워크


<br>
<br>

***
#### GET Flooding
: 정상적인 TCP 연결과정 이후 정상적으로 보이는 HTTP Transaction 과정이 수행되는 DDoS공격 기법이다.

TCP 3-Way Handshake 과정 이후 정상적으로 보이는 트랜잭션이 추가적으로 발생되는 DDoS 공격 기법이다. 일반적으로 DDoS공격은 웹 서버를 대상으로 DDoS 공격이 발생되며, TCP 세션 연결 이후 발생하는 일반적인 공격 형태가 바로 HTTP Get Flooding 형태이다. 

공격 트래픽을 수신하는 서버는 정상적인 TCP 세션과 함께 정상적으로 보이는 HTTP Get 요청을 지속적으로 요청하게되므로, 시브스를 위하여 수행하는 서버는 기본적인 TCP 세션 처리뿐만 아니라 HTTP 요청 처리까지 수행 해야 한다. 이 경우 HTTP 모듈의 과부하 까지도 야기시킬 수 있는 DDoS 공격 기법이다. 


<br>
<br>

***
####  SYN Flooding
: 공격자는 다량의 Syn 패킷을 서버로 전달하여 서버의 대기큐를 가득채워 새로운 클라이언트의 연결요청을 무시하도록 하여 장애를 유발 시키는 공격 

TCP 연결과정(3-Way Handshaking)의 처음 단계인 SYN 패킷 전송 단계에서 공격자는 대량의 SYN패킷을 생성하여 서버로 전달. 

TCP 연결요청을 수용할 때 사용하는 서버의 대기 큐(Backlog Queue) 가 가득(Full)차게 되어, 이후 들어오는 연결요청을 무시하도록 하는 서비스 거부 상태가 됨 

SYN 패킷만 전송하고 SYN-ACK에 대한 응답인 ACK 패킷을 전송하지 않으면 Half Open상태(75초)가 되며 이때 계속해서 Syn 패킷을 보내 Backlog Queue를 가득 채우고 더이상의 TCP 신규 접속을 받지 못하게됨.


<br>
<br>

***
####  UDP Flooding
: UDP Flooding은 DoS 공격(Denial-of-service attack)의 한 종류로써 많은 수의 UDP packet을 victim에 전송하여 정상적인 서비스가 불가능하도록 하는 공격이다.

UDP packet은 spoofed IP와 port를 사용하여 IP filter를 이용해서는 차단하기가 어렵다.    네트워크 bandwidth를 소모하기 때문에 특정 서비스가 아니라 victim의 모든 서비스가 불가능해지며 특정 포트가 열려있을 필요도 없다. 모든 flooding 공격류의 특징이 그러하듯 패킷 자체에는 특이점이나 패턴이 존재하지 않으므로 차단하기가 쉽지 않다.

UDP 공격의 경우 synflood와 달리 네트워크 bandwidth 를 소모시키는 것이 목적이다.    
따라서, 단일 호스트로는 효과를 볼 수 없기 때문에 ,DDoS로 구성해서 공격이 이루어진다.     
(DDoS를 수행하기 위해서는 최소 수백대의 Zombie호스트가 필요) 

<br>
<br>


***
#### ICMP Flooding
: 대량의 ping 패킷을 보내는 공격   

대상 시스템에 막대한 양의 ICMP 에코 요청 패킷(ping 패킷)을 보내는 방법이다.     
유닉스 계열의 시스템에서는 ping 명령을 이용하며, ping 응답을 기다리지 않고 되도록 빨리 ICMP 패킷을 보내는 ping 옵션을 활용하는 것이 가장 효율적인 방법이다.    

대상 시스템에 부하를 일으키기 위해서는 ping을 보내는 쪽의 네트워크 대역폭이 대상 시스템이 확보한 네트워크 대역폭보다 더 크면 된다.

<br>
<br>

***
####  CLDAP DDoS Attack
: 해커가 여러 LDAP서버에 자기 자신의 IP를 타겟 IP로 변조하여 쿼리를 보내면, 서버는 데이터를 처리한 후 증폭된 응답 패킷을 변조된 타겟 IP로 보내는 방식

CLDAP(Connection-less Lightweight Directory Access Protocol)란

\# LDAP란 경량 디렉토리 엑세스 프로토콜의 약자로 사이버 TCP/IP에서 디렉토리 서비스를 조회하고 수정하는 응용 프로토콜을 말함

\# CLDAP란 클라이언트들이 마이크로소프트 액티브 디렉토리 네트워크로부터 서버의 사용자 계정과 비밀번호에 접근할 때 사용됨

\# 최근 DDoS공격 중 LDAP/CLDAP 두 개의 프로토콜을 이용하는 공격이 자주 발견되고 있음

1) 공격자들이 특별히 제작된 패킷을 인터넷을 통해 여러 UDP 서버로 보낸다.
2) 이 패킷은 디도스 공격의 표적이 될 시스템의 IP로부터 나온 것처럼 보인다.
3) UDP 서버가 그에 대한 응답을 표적 시스템(피해 시스템)의 IP로 보낸다.
4) 이 때 그 응답은 1)번 단계의 패킷 조작을 통해 매우 용량이 커진 상태다.
5) 큰 용량의 응답을 받은 표적 시스템은 마비가 된다. 

※특징
CLDAP 프로토콜은 통신할 때 TCP가 아닌 UDP를 사용하기 때문에 패킷 송신 IP를 확인하지 않고, 이를 이용한 DDoS 공격의 증폭은 56%가 넘는다고 함

“CLDAP 반사 공격의 원리는 다른 UDP 기반의 반사 공격의 그것과 동일하다”고 설명한다. “하지만 증폭이 월등하죠. CLDAP를 통한 디도스 공격의 증폭은 56%가 넘습니다.” - 보안뉴스 기사 발췌

<br>
<br>

***
#### TCP Connection Flooding
:TCP Connection Flooding 은 TCP 3-Way Handshake 과정을 과도하게 유발함으로써 서비스의 과부하를 야기시키는 공격 유형이다.

공격 트래픽을 수신하는 서버는 정상적인 TCP 세션을 지속적으로 세션 연결을 하여 서비스를 위하여 수행하는 서버의 세션 처리 자원(Resource)를 고갈시켜 정상적인 세션 연결을 더 이상 수행하지 못하게 한다. 결국 정상적으로 접근하는 사용자가 더 이상 서비스에 접근할 수 없게 된다. 이 공격 기법을 세분화하면 크게 세 가지로 나눠볼 수 있다.

1. TCP 세션 연결을 유지하는 DDoS 공격
2. TCP 세션 연결/해제를 반복하는 DDoS 공격
3. TCP 세션 연결 후 정상적인 트랜잭션(Transaction)처럼 보이는 트래픽을 발송하는 DDoS 공격

<br>
<br>

***
#### Http GET Flooding
: 일반적으로 DDoS 공격은 웹 서버(Web Service)를 대상으로 DDoS 공격이 발생되며, TCP 세션 연결 이후 발생하는 일반적인 공격 형태가 바로 HTTP Get Flooding 형태가 그것이다.    
다시 말하면, HTTP Get Flooding 은 정상적인 TCP 연결 과정 이후 정상적으로 보이는 HTTP Transaction 과정이 수행되는 DDoS 공격 기법이다.

앞서 설명한 TCP Connection Flooding 의 경우 TCP 3-Way Handshake 과정 이후 정상적인 트랜잭션이 일어나지 않는 반면 TCP 3-Way Handshake 과정 이후 정상적으로 보이는 트랜잭션이 추가적으로 발생되는 DDoS 공격 기법이다. 

공격 트래픽을 수신하는 서버는 정상적인 TCP 세션과 함께 정상적으로 보이는 HTTP Get 요청을 지속적으로 요청하게 되므로, 서비스를 위하여 수행하는 서버는 기본적인 TCP 세션 처리뿐만 아니라 HTTP 요청 처리까지 수행해야 한다. 이 경우 HTTP 처리 모듈의 과부하까지도 야기시킬 수 있는 DDoS 공격 기법이다.

전통적인 DDoS 공격 대응 장비에서 이러한 HTTP Get Flooding 공격을 방어하기 위해서는 일반적으로 임계치 기반의 방어 기법을 적용한다. 즉 HTTP Get Flooding 시 수행되는 TCP 연결 요청의 임계치 값과 HTTP Get 요청의 임계치 값의 모니터링을 통하여 비정상적으로 많은 트래픽을 발생하는 출발지 IP에 대한 선별적인 차단 적용이 가능해 진다. 다행히도 이러한 세션 연결 기반 공격의 경우 출발지 IP는 변조될 수가 없기 때문에 출발지 IP 기준의 임계치를 통하여 방어가 가능하다.
<br>
<br>

***
#### ㅁ HTTP 취약점 - 서비스 거부 공격
***

<br>

### Slow HTTP POST DoS     
: RUDY(RU-Dead-Yet?) 공격이라고도 부른다.       
POST 메소드로 대량의 데이터를 장시간에 걸쳐 분할 전송하여 연결을 장시간 유지시킨다.     
서버가 POST 데이터를 모두 수신하지 않았다고 판단하면 전송이 다 이루어질때 까지 연결을 유지하는 성격을 이용한다.      
예를 들어 Content-Length를 100000byte로 하고 데이터는 일정한 간격으로 1byte씩 전송한다.   
이러한 연결을 다량 만들어 각각의 연결이 장시간 유지되도록 하여 가용성을 해친다   
***

<br>

### Slow HTTP Header DoS       
: Slowloris 공격이라고도 부른다.  
HTTP Header 정보를 비정상적으로 조작하여 웹서버가 온전한 Header정보가 올때 까지 기다리도록 한다.   
서버가 연결 상태를 유지할 수 있는 가용자원은 한계가 있으므로 임계치를 넘어가면 다른 정상적인 접근을 거부하게 된다.   

ㅁ 동작   
HTTP에선 헤더의 끝을 /r/n 이라는 개행문자로 구분한다.   
공격자는 이 마지막 개행문자를 보내지 않고 지속적으로 의미없는 변수를 추가한다.   
서버는 헤더 정보가 아직 전송 중이라고 인식하고 연결을 유지한다.   

ㅁ 대응  방법
공격자가 동시에 많은 세션을 유지하므로 방화벽 등을 통하여 세션 임계치 제한을 설정한다.   
공격자가 헤더를 천천히 전달하며 연결 시간을 지속시키므로 연결 타임아웃 시간을 적절히 짧게 두어 의심되는 연결이 종료되도록 한다.   

단, 너무 짧게 둘 경우 일부 느린 네트워크의 정상적인 연결에 대해서도 가용성을 해칠 수 있다. 
***
- Slow HTTP Read DoS   
: 정상트래픽 이라면 Window Size가 가변적이지만 공격 트래픽은 Window Size가 "0"으로 고정   
매우 작은 윈도우크기로 서버에 응답을 보내면 서버는 더 이상 데이터를 전송하지 못하고 연결만 유지한 상태로 대기   
  
<br>
<br>

***
#### DNS 관련 공격
***

### DNS Spoofing Attack
: 희생자가 DNS 질의를 수행하면 공격자가 이를 스니핑하고 있다가 ​정상 응답보다 빠르게 ​희생자에게 조작된 IP 정보가 담긴 DNS 응답을 보내 정상 주소(URL)을 입력하더라도 조작된 주소로 접속하게 하는 공격기법.

조작된 응답 이후에 도착한 정상 응답은 먼저 수신한 응답을 신뢰하는 특성으로 폐기 된다.

- 대응방법
1. 사전에 스니핑이 되어야 되기 때문에 스니핑 탐지 및 차단       
2. 중요한 사이트의 IP 주소에 대해서는 DNS 질의보다 우선순위가 높은 hosts 파일에 등록해서 관리

<br>
<br>

### DNS 캐시 포이즈닝 (Cache Poisoning)
: DNS 서버는 상위 서버에게 빈번하게 반복적인 질의 (Iterative Query)를 요청하여 부하 발생을 막기 위해 캐시(Cache)를 사용한다. 이 캐시는 TTL(Time To Live) 동안만 유지된다.

DNS 서버 자체를 공격하는 것이기에 DNS 캐시정보가 일정시간(TTL) 유지 되는 동안 해당 서버에 접근하는 다수의 사용자들이 DNS 응답을 수신하게 된다.

- 공격방법
> 1. 공격자가 공격 대상의 DNS 서버에 조작할 도메인에 대해서 존재하지 않는 서브도메인 주소로 Recursive 질의를 다수 보낸다. 예를 들어서 q001.bankofamerica.com              
> 2. DNS 서버는 질의에 대한 IP 주소가 없기 때문에 bankofamerica.com에 질의를 하므로써 반복적인 질의(Recursive Query)를 수행한다.           
> 3. bankofamerica.com 네임서버에서 NXDOMAIN이라는 응답이 오기 전, 공격자는 www .bankofamerica.com의 IP주소를 공격자가 원하는 IP주소 조작한 수 많은 응답을 DNS 서버에 보낸다.          
> 4. DNS 서버는 조작된 응답을 받아들이고, 캐시에 저장한다.         
> 5. 일반 사용자들이 DNS 서버에  www .bankofamerica.com의 IP 주소에 대해 질의를 한다.          
> 6. DNS 서버는 조작된 IP주소를 응답해준다.          
> 7. 일반 사용자들은 진짜 bank of america 웹사이트와 비슷한 조작된 주소로 접속하게된다.       

- 대응방법
1. 네임서버의 소프트웨어를 최신 버전 상태로 유지   
2. 도메인 관리용 DNS 서버는 재귀적 질의를 허용하지 않도록 설정하고, 제한된 사용자가 사용하는 Recursive DNS 서버라면 해당 사용자로 제한해서 허용하도록 한다.   

allow-recursion 설정   
DNS 서버는 기본 설정으로 모든 IP에 대해서 재귀적 질의를 허용한다.

3. 모든 재귀적 질의 차단 : allow-recursion {none;​}; 으로 설정하거나 recursion no로 설정   
4. 제한된 사용자만 사용 : allow-recursion {IP 또는 IP대역;}; 또는 별도의 acl (access control list)를 정의

- DNSSEC 기술 활용
: IETF에 의해 2005년 완성된 국제표준기술로, 데이터 위변조 공격에 취약한 DNS의 문제점을 근본적으로 보안 개선하기 위함.    
\# DNS대체하는 것이 아니라, 기존의 DNS에 공개키 암호화 방식의 보안 기능을 추가 부여하여 DNS의 보안성을 대폭 강화

<br>
<br>

### DNS를 활용한 증폭 DrDoS
\# DrDOS 정의 
: 출발지 IP를 공격대상의 IP로 위조한 후 다수의 반사서버에 요청하면 공격대상은 반사서버로부터 대량의 응답을 받아 서비스 거부 상태가 된다.

- DNS DrDos 과정
> 1. 우선, source IP주소를 희생자의 IP주소로 스푸핑을 합니다.    
> 2. 공격자는 DNS서버(open된 resolving DNS)에 any 또는 txt와 같은 요청에 비해 응답의 크기가 큰 쿼리(query)를 보냅니다.   
> 3. DNS 서버는 query에 대한 응답을 희생자에게 보냅니다.   
> 4. 그 결과, 희생자는 매우 큰 사이즈의 응답을 받게 됩니다.    
> 5. 공격자 입장에서, 작은 크기의 패킷을 큰 사이즈의 패킷으로 증폭하여 공격할 수 있어 효율적인 공격방법이다.    

- 대응방법

1) 포트기반의 ACL 차단
   - DNS의 경우 UDP를 사용하기 때문에 protocol 기반의 ACL은 적용하기 힘들다   
   - 공격 트래픽이 DNS 서버에서 응답패킷이므로 소스포트는 53, 응답포트는 53 또는 1024 이상의 랜덤 포트가 된다. 따라서 소스포트가 53/udp인 inbound 트래픽을 차단하는 ACL 적용   
   - 
2) 공격 IP는 resolving이 허용된 DNS 서버에서 지속적인 공격 트라픽이 유발되므로 ratelimit를 적용하여, 한 소스 IP에서의 inbound 트래픽을 제한하도록 한다. 

3) 수십~수백Gbps의 충분한 대역폭이 없다면 KISA 대피소 서비스를 활용하거나 Anycast등의 대응이 가능한 Cloud 기반의 서비스를 이용

***

### 회선 태핑(Tapping) 공격
: 전기 신호를 직접 자신에게 끌어오는 방식

대응 방법 : 광섬유(광섬유는 어떤 유형의 신호도 외부로 방출할 수 없게 설계되어 있어 전기 신호를 직접 끌어오는 것을 방지할 수 있다.)

### 템페스트(Tempest) 공격
: 전송 매체에 흐르는 전기 신호를 검출해 데이터를 해석하는 기법으로 무선분야에서 광범위하게 일어난다.

Ex) 워 드라이빙(war driving) 공격, PC스피커의 전기 신호를 이용한 공격 등

### VLAN 홉핑 공격
: 자신과 다른 VLAN영역으로 넘어가는 기법

VLAN영역은 논리적으로 다른 영역이기 때문에 원래는 넘어갈 수 없다. 이를 무시하고 다른 VLAN 영역으로 넘어갈 때 사용하는 공격이다.

### DHCP 스푸핑 공격
: DHCP 고갈 공격으로 IP주소 고갈 상태에 놓은 DHCP 대신 공격자가 DHCP 사용자들에게 조작한 게이트웨이 ID 또는 DNS 서버를 할당하는 공격 기법

조작한 게이트웨이 IP주소에 공격자의 IP주소를 할당해 DHCP 사용자들의 모든 데이터들을 공격자에게 흐르게 할 수 있다.

### 본크·보인크(Bonk·Boink) 공격
: TCP 단편화 속성을 악용해 TCP 헤더 중 일련번호 항목을 조작해 수신 측에서 정상적인 재조립을 할 수 없도록 하여 과부하를 일으키는 기법

bonk: 같은 시퀀스 번호 보내는것
boink: 정상적으로 보내는 것처럼 보내다가 bonk로 공격하는것.
teardrop: 패킷 1의 시퀸스 번호를 1 ~ 101로 보내고, 패킷 2의 시퀸스 번호를 81 ~ 181 로 보내는 식


티얼드롭 공격처럼 대부분읜 운영체제는 일련번호 항목이 일정 시간동안 불일치할 경우, 해당 세그먼트 전체를 폐기하는 방식으로 해당 공격을 차단한다.

### Tiny Fragment Attack
: 초의 패킷 조각을 아주 작게 만들어 네트워크 침입탐지 시스템(IDS)이나 패킷 필터링 장비를 
우회하는 공격을 말합니다. 패킷 필터링 장비나 침입탐지시스템은 필터링을 결정하기 위해 포트번호를 확인하는데 포트번호가 포함되지 않을 정도로 아주 작게 단편화된 첫 번째 조각을 통과시킵니다. 또한 실제 포트번호가 포함되어 있는 두 번째 조각은 아예 검사도 하지 않고 통과시킵니다. 그 결과 보호되어야 할 목적지 서버에서는 이 패킷들이 재조합되어 공격자가 원하는 포트의 프로그램으로 무사히 연결될 수 있습니다. 이런 방법으로 패킷 필터링에서 차단되어야 하는 패킷을 통과시킬 수도 있고, 침입 탐지 시스템에서 비정상적인 접속으로 경보 되어져야 하지만 전혀 탐지되지 않게 할 수도 있습니다.

### Fragment Ovelap Attack 
: 첫 번째 조각에서는 필킷 필터링 장비에서 허용하는 http 포트와 같은 포트번호를 가집니다. 그리고, 두 번째 조각에서는 오프셋을 아주 작게 조작합니다.    
방화벽은 정상적인 포트로 오인하여 패킷을 호스트에게 전달하도록 허락합니다. 조각들이 재조합 될 때 두 번째 조각과 첫 번째 조각의 일부분을 덮어쓰도록 하여 공격이 성공합니다.

### 세션 하이재킹
: 클라이언트와 서버간의 통신을 관찰 할 수 있을 뿐만 아니라 신뢰를 이용한 세션은 물론, Telnet, FTP 등 TCP를 이용한 거의 모든 세션의 갈취가 가능합니다. 현재 연결중인 세션을 가로채어 사용자의 ID와 패스워드를 사용하는 인증 절차를 무시할 수도 있습니다. 

### Smishing
:  문자 메시지(SMS)에 링크를 거는 등 문자 메시지를 이용해 사용자의 개인 신용 정보를 빼내는 수법

### Spear Phishing
: 사회 공학의 한 기법으로, 인간 상호 작용의 깊은 신뢰를 바탕으로 특정 대상을 선정한 후 메일의 링크나 파일을 클릭하도록 유도한 뒤 개인 정보를 탈취하는 수법

### Qshing
: QR코드와 개인정보 및 금융정보를 낚는다(Fishing)의 합성 신조어

***              
#### ㅁ 파일 업로드 공격                 
: 공격자는 웹 애플리케이션의 파일 업로드 기능을 이용, 웹쉘이라고 하는 악성 파일을 업로드, 시스템 명령을 실행                   
- 파일 업로드 취약점 : 파일을 업로드하는 기능에 적절한 보안 대책이 적용되어 있지 않을 때 발생                
Ex. 게시판에 파일을 첨부/사용자 프로필에 사진을 업로드, SNS 사진/파일 업로드도 포함됨                                   
- 파일 업로드 기능 구현 시 아무 파일이나 업로드 허용                                 
  => 공격자는 웹쉘(web shell)이라고 하는 악성 파일 업로드 => 시스템 침투                 
* 커맨드 인젝션 공격과 유사 -> 웹을 통해 시스템 명령어를 실행할 수 있는 웹 페이지의 일종(그래서 이름이 웹쉘)                   

- 앞서 다운로드한 webshell.php 파일                   
 
   -> 명령어를 입력받는 폼 제공 + 명령어를 cmd 파라미터로 전달
   -> system() 함수를 이용하여 명령어 실행
           
***
#### ㅁ Ping of death    
: ICMP Packet을 정상적인 크기보다 아주 크게 만들어 Fragmented Packet 과 비정상적인 OOB(Out of Band)를 함께 대량으로 전송하여,, 해당 시스템 자원을 소모시키는 공격

***

#### ㅁ Trinoo
: Master/Agent로 구성 DDoS 공격도구, 공격자가 하나 혹은 그 이상의 시스템에서 여러 개의 데몬에게 명령을 내려 특정 시스템을 공격하는 UDP Flooding 공격을 수행한다.

***

#### ㅁ John The Ripper    
: 다양한 패스워드 형식을 가지는 파일을 점검하는 도구지만, 패스워드 크래커로 사용되는 도구.

***

#### 스턱스 넷
: 원자력 발전소 작동을 방해한 악성코드 SCADA(Supervisory Control And Data Acquisition)시스템을 임의로 제어하는데 사용. 내부 폐쇄망에서 다른 시스템들로 유포하기 위해 여러 개의 취약점을 사용했다.   
독일 지멘스 소프트웨어 구조를 정확하게 파악하여 관련 파일을 변조했다.
***

#### DHCP Starvation
: DHCP(Dynamic Host Configuration Protocol)를 대상으로 하는 공격으로 IP주소를 고갈시켜 서비스를 불가능하게 만든다.   
> 다수의 클라이언트를 이용하여(또는 조작된 MAC을 통하여) DHCP discover 메세지를 보낸다.   
> DHCP offer가 오면 DHCP request를 보내고, DHCP Ack까지 받아 실질적으로 IP를 할당받는다.   
> 서버는 가지고 있는 IP가 소진되어 더이상 서비스를 할 수 없다.   

***

#### ㅁ ARP Spoofing
: ARP 프로토콜을 이용하여 동일 네트워크에 존재하는 두 Victim의 ARP 테이블에서 두 Victim의 IP에 대한 MAC주소를 Attacker자신의 MAC주소로 바꾸는 공격이다.

***

#### ㅁ ARP Redirect
: ARP Spoofing에서 속이는 대상을 게이트웨이로 한 것이다.
 Victim은 Attacker가 Gateway인 줄 알고 외부로 통신할 때 Attacker에게 패킷을 보내기 때문에 외부로 나가는 패킷을 Sniffing할 수 있다.

***

#### ㅁ ICMP Redirect
 : 라우터가 송신 측 호스트에 적합하지 않은 경로로 되어 있으면 해당 호스트에 대한 최적 경로를 다시 지정해주는 ICMP Type (이를 악용하면 패킷을 가로채는 것이 가능.)


---

### ㅁ Dos vs DDoS vs DRDOS

ㅁ DOS(Denial of Service)공격

- 타겟 시스템의 자원을 고갈 시키거나 네트워크 대역폭을 초과시켜 원래 의도된 용도로 사용하지 못하게 하는 공격이다. (가용성을 침해한다.)
- DDOS와의 차이점은 Attacker가 직접 공격을 수행한다는 점이다.

1. Ping of Death

개념]

- ICMP Echo Request 패킷의 크기를 정상 크기보다 아주 크게 만들어 공격 네트워크에 도달하는 동안 아주 작은 조각으로 쪼개져 Victim이 쪼개진 조각을 모두 처리하게 하여 부하가 걸리도록 하는 공격이다.

대응법]

- 반복적으로 들어오는 일정한 수 이상의 ICMP 패킷을 무시하도록 설정한다. (대부분의 시스템에서 이미 설정이 되어있다.)

- System 보안 패치를 한다.


2. Smurf Attack

개념]

- Attacker가 출발지 IP를 Victim의 IP로 Spoofing하여 ICMP Request패킷을 시스템이 아주 많은 네트워크를 Broadcast하면 해당 패킷을 받은 네트워크가 Victim에게 ICMP Reply패킷을 대량으로 보내는 공격이다.

대응법]

- 라우터에서 Direct Broadcast를 차단한다. (대부분의 라우터에서 이미 Default로 차단되어 있다.)


3. SYN Flooding

개념]

- 3way handshake취약점을 이용하여 Backlog Queue가 초과하도록 만드는 공격이다.

- Attacker가 SYN 패킷을 보낸 후 SYN+ACK 패킷이 돌아와도 ACK 패킷을 보내지 않아 Victim이 SYN Received 상태로 ACK 패킷을 계속 기다리는 상태로 만든다. (Backlog에 빠지도록 만든다.)

- 이런식으로 계속 SYN 패킷을 보내어 Victim의 Backlog Queue를 초과하도록 만든다.

대응법] 

- Backlog Queue크기를 늘려준다.
- System 보안 패치를 한다.
- SYN Cookie를 이용한다.
- IDS, IPS에서 정형화된 SYN Flooding 패킷을 탐지한다.

4. Land Attack

개념]

- 대량의 패킷의 출발지 IP주소와 목적지 IP 주소를 같게 만들어서 Victim에게 보내는 공격이다.

대응법]

- 출발지 IP 주소와 목적지 IP 주소를 확인하여 동일한 패킷은 버린다. (현재 대부분의 시스템은 이미 적용하고 있다.)
- 라우터나 방화벽에서 출발지 IP 주소와 내부 IP주소가 동일한 패킷은 차단한다.

5. DHCP Starvation

개념] 

- 공격자가 MAC Address를 계속 변경하여 DHCP Server로부터 IP를 할당받아서 DHCP Server가 보유하고 있는 모든 IP 주소를 할당받아 정작 정상적인 호스트가 IP를 할당받지 못하게 하는 방식이다.

대응법]

- port security기능을 사용한다. port security기능을 사용하면 해당 MAC Address에게만 IP를 할당하거나 해당 Port에 최대로 줄 수 있는 IP개수를 제한할 수 있다.
